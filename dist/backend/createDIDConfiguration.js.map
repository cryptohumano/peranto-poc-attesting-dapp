{"mappings":"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","sources":["src/backend/utilities/configuration.ts","src/backend/cTypes/domainLinkageCType.ts","src/backend/utilities/keypairs.ts","src/backend/utilities/initKilt.ts","src/backend/utilities/didDocument.ts","src/backend/utilities/cryptoCallbacks.ts","src/backend/utilities/domainLinkageCredential.ts","src/backend/createDIDConfiguration.ts"],"sourcesContent":["import { cwd } from 'node:process';\nimport path from 'node:path';\n\nimport { config } from 'dotenv';\nimport { pino } from 'pino';\nimport { DidUri } from '@kiltprotocol/sdk-js';\n\nconfig();\n\nclass ConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    pino().fatal(message);\n    process.exit(1);\n  }\n}\n\nconst { env } = process;\n\nconst baseUri = env.URL;\nif (!baseUri) {\n  throw new ConfigurationError('URL is not provided');\n}\n\nconst did = env.DID as DidUri;\n\nconst payerMnemonic = env.SECRET_PAYER_MNEMONIC;\nif (!payerMnemonic) {\n  throw new ConfigurationError('SECRET_PAYER_MNEMONIC is not provided');\n}\nconst authenticationMnemonic = env.SECRET_AUTHENTICATION_MNEMONIC;\nif (!authenticationMnemonic) {\n  throw new ConfigurationError(\n    'SECRET_AUTHENTICATION_MNEMONIC is not provided',\n  );\n}\nconst assertionMethodMnemonic = env.SECRET_ASSERTION_METHOD_MNEMONIC;\nif (!assertionMethodMnemonic) {\n  throw new ConfigurationError(\n    'SECRET_ASSERTION_METHOD_MNEMONIC is not provided',\n  );\n}\nconst keyAgreementMnemonic = env.SECRET_KEY_AGREEMENT_MNEMONIC;\nif (!keyAgreementMnemonic) {\n  throw new ConfigurationError('SECRET_KEY_AGREEMENT_MNEMONIC is not provided');\n}\n\nconst blockchainEndpoint = env.BLOCKCHAIN_ENDPOINT;\nif (!blockchainEndpoint) {\n  throw new ConfigurationError('No blockchain endpoint provided');\n}\n\nconst adminUsername = env.ADMIN_USERNAME;\nconst adminPassword = env.ADMIN_PASSWORD;\nif (!adminUsername || !adminPassword) {\n  throw new ConfigurationError('Admin credentials missing');\n}\n\nexport const configuration = {\n  port: parseInt(env.PORT as string) || 3000,\n  blockchainEndpoint,\n  baseUri,\n  distFolder: path.join(cwd(), 'dist', 'frontend'),\n  did,\n  payerMnemonic,\n  authenticationMnemonic,\n  assertionMethodMnemonic,\n  keyAgreementMnemonic,\n  adminUsername,\n  adminPassword,\n};\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const domainLinkageCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'Domain Linkage Credential',\n  properties: {\n    id: {\n      type: 'string',\n    },\n    origin: {\n      type: 'string',\n    },\n  },\n  type: 'object',\n  $id: 'kilt:ctype:0x9d271c790775ee831352291f01c5d04c7979713a5896dcf5e81708184cc5c643',\n};\n","import { Utils } from '@kiltprotocol/sdk-js';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nimport { configuration } from './configuration';\n\nexport const keypairsPromise = (async () => {\n  await cryptoWaitReady();\n\n  const payer = Utils.Crypto.makeKeypairFromUri(configuration.payerMnemonic);\n\n  const authentication = Utils.Crypto.makeKeypairFromUri(\n    configuration.authenticationMnemonic,\n  );\n\n  const assertionMethod = Utils.Crypto.makeKeypairFromUri(\n    configuration.assertionMethodMnemonic,\n  );\n\n  const keyAgreement = Utils.Crypto.makeEncryptionKeypairFromSeed(\n    Utils.Crypto.mnemonicToMiniSecret(configuration.keyAgreementMnemonic),\n  );\n\n  return {\n    payer,\n    authentication,\n    assertionMethod,\n    keyAgreement,\n  };\n})();\n","import { connect } from '@kiltprotocol/sdk-js';\n\nimport { configuration } from './configuration';\n\nexport async function initKilt(): Promise<void> {\n  await connect(configuration.blockchainEndpoint);\n}\n","import type { DidDocument, KeyRelationship } from '@kiltprotocol/sdk-js';\nimport { Did, Utils } from '@kiltprotocol/sdk-js';\n\nimport { keypairsPromise } from './keypairs';\nimport { configuration } from './configuration';\nimport { initKilt } from './initKilt';\n\nasync function compareKeys(\n  configured: { publicKey: Uint8Array },\n  resolved: { publicKey: Uint8Array } | undefined,\n  relationship: KeyRelationship,\n): Promise<void> {\n  if (!resolved) {\n    throw new Error(\n      `Your on-chain DID is broken: the resolved key for ${relationship} is undefined`,\n    );\n  }\n\n  const derivedHex = Utils.Crypto.u8aToHex(configured.publicKey);\n  const resolvedHex = Utils.Crypto.u8aToHex(resolved.publicKey);\n\n  if (derivedHex !== resolvedHex) {\n    throw new Error(\n      `Your on-chain DID is broken: the configured key for ${relationship} does not match resolved one`,\n    );\n  }\n}\n\nasync function compareAllKeys(fullDid: DidDocument): Promise<void> {\n  const keypairs = await keypairsPromise;\n\n  await compareKeys(\n    keypairs.authentication,\n    fullDid.authentication[0],\n    'authentication',\n  );\n  await compareKeys(\n    keypairs.assertionMethod,\n    fullDid.assertionMethod?.[0],\n    'assertionMethod',\n  );\n  await compareKeys(\n    keypairs.keyAgreement,\n    fullDid.keyAgreement?.[0],\n    'keyAgreement',\n  );\n}\n\nexport const didDocumentPromise = (async () => {\n  await initKilt();\n\n  const { did } = configuration;\n  if (!did) {\n    throw new Error('DID not configured, have you run createDID script?');\n  }\n\n  const resolved = await Did.resolve(did);\n  if (!resolved || !resolved.document) {\n    throw new Error(\n      `Could not resolve the configured DID ${did}, have you run createDID script?`,\n    );\n  }\n\n  const { document } = resolved;\n  await compareAllKeys(document);\n\n  const authenticationKey = document.authentication?.[0];\n  if (!authenticationKey) {\n    throw new Error('Impossible: authentication key not found');\n  }\n\n  const assertionMethodKey = document.assertionMethod?.[0];\n  if (!assertionMethodKey) {\n    throw new Error('Impossible: assertion method key not found');\n  }\n\n  const keyAgreementKey = document.keyAgreement?.[0];\n  if (!keyAgreementKey) {\n    throw new Error('Impossible: key agreement key not found');\n  }\n\n  return {\n    did,\n    didDocument: document,\n    authenticationKey,\n    assertionMethodKey,\n    keyAgreementKey,\n  };\n})();\n","import {\n  DecryptCallback,\n  DidResourceUri,\n  EncryptCallback,\n  SignRequestData,\n  Utils,\n} from '@kiltprotocol/sdk-js';\n\nimport { keypairsPromise } from './keypairs';\nimport { didDocumentPromise } from './didDocument';\n\nexport async function sign({ data, keyRelationship }: SignRequestData) {\n  if (keyRelationship === 'capabilityDelegation') {\n    throw new Error('Delegation not supported');\n  }\n  const { authentication, assertionMethod } = await keypairsPromise;\n  const { did, authenticationKey, assertionMethodKey } =\n    await didDocumentPromise;\n\n  const [keypair, publicKey] =\n    keyRelationship === 'authentication'\n      ? [authentication, authenticationKey]\n      : [assertionMethod, assertionMethodKey];\n\n  const keyUri: DidResourceUri = `${did}${publicKey.id}`;\n\n  return {\n    signature: keypair.sign(data, { withType: false }),\n    keyType: keypair.type,\n    keyUri,\n  };\n}\n\nexport async function signWithAssertionMethod({ data }: { data: Uint8Array }) {\n  const { assertionMethod } = await keypairsPromise;\n\n  const { did, assertionMethodKey } = await didDocumentPromise;\n  const keyUri: DidResourceUri = `${did}${assertionMethodKey.id}`;\n\n  return {\n    signature: assertionMethod.sign(data, { withType: false }),\n    keyType: assertionMethod.type,\n    keyUri,\n  };\n}\n\nexport async function encrypt({\n  data,\n  peerPublicKey,\n}: Parameters<EncryptCallback>[0]) {\n  const { keyAgreement } = await keypairsPromise;\n\n  const { did, keyAgreementKey } = await didDocumentPromise;\n  const keyUri: DidResourceUri = `${did}${keyAgreementKey.id}`;\n\n  const { box, nonce } = Utils.Crypto.encryptAsymmetric(\n    data,\n    peerPublicKey,\n    keyAgreement.secretKey,\n  );\n\n  return {\n    data: box,\n    nonce,\n    keyUri,\n  };\n}\n\nexport async function decrypt({\n  data: box,\n  nonce,\n  peerPublicKey,\n}: Parameters<DecryptCallback>[0]) {\n  const { keyAgreement } = await keypairsPromise;\n\n  const data = Utils.Crypto.decryptAsymmetric(\n    { box, nonce },\n    peerPublicKey,\n    keyAgreement.secretKey,\n  );\n  if (!data) {\n    throw new Error('Failed to decrypt with given key');\n  }\n\n  return {\n    data,\n  };\n}\n","import {\n  Claim,\n  Credential,\n  IClaimContents,\n  ICredentialPresentation,\n} from '@kiltprotocol/sdk-js';\nimport {\n  constants,\n  Proof,\n  VerifiableCredential,\n} from '@kiltprotocol/vc-export';\n\nimport { configuration } from './configuration';\nimport { domainLinkageCType } from '../cTypes/domainLinkageCType';\nimport { signWithAssertionMethod } from './cryptoCallbacks';\n\nconst {\n  DEFAULT_VERIFIABLECREDENTIAL_CONTEXT,\n  DEFAULT_VERIFIABLECREDENTIAL_TYPE,\n  KILT_SELF_SIGNED_PROOF_TYPE,\n  KILT_VERIFIABLECREDENTIAL_TYPE,\n} = constants;\n\nconst context = [\n  DEFAULT_VERIFIABLECREDENTIAL_CONTEXT,\n  'https://identity.foundation/.well-known/did-configuration/v1',\n];\n\nconst TTL = 1000 * 60 * 60 * 24 * 365 * 5; // 5 years\n\nexport async function attestDomainLinkage(): Promise<ICredentialPresentation> {\n  const claimContents = {\n    id: configuration.did,\n    origin: configuration.baseUri,\n  };\n\n  const claim = Claim.fromCTypeAndClaimContents(\n    domainLinkageCType,\n    claimContents,\n    configuration.did,\n  );\n\n  const credential = Credential.fromClaim(claim);\n\n  return Credential.createPresentation({\n    credential,\n    // the domain linkage credential is special in that it is signed with the assertionMethod key\n    signCallback: signWithAssertionMethod,\n  });\n}\n\ninterface DomainLinkageCredential\n  extends Omit<\n    VerifiableCredential,\n    '@context' | 'id' | 'legitimationIds' | 'credentialSubject' | 'proof'\n  > {\n  '@context': typeof context;\n  credentialSubject: IClaimContents;\n  proof: Proof;\n}\n\nexport function fromCredential(\n  input: ICredentialPresentation,\n): DomainLinkageCredential {\n  const credentialSubject = {\n    ...input.claim.contents,\n    rootHash: input.rootHash,\n  };\n  const issuer = input.claim.owner;\n\n  const issuanceDate = new Date().toISOString();\n  const expirationDate = new Date(Date.now() + TTL).toISOString();\n\n  const { claimerSignature } = input;\n\n  // add self-signed proof\n  const proof = {\n    type: KILT_SELF_SIGNED_PROOF_TYPE,\n    proofPurpose: 'assertionMethod',\n    verificationMethod: claimerSignature.keyUri,\n    signature: claimerSignature.signature,\n    challenge: claimerSignature.challenge,\n  };\n\n  return {\n    '@context': context,\n    issuer,\n    issuanceDate,\n    expirationDate,\n    type: [\n      DEFAULT_VERIFIABLECREDENTIAL_TYPE,\n      'DomainLinkageCredential',\n      KILT_VERIFIABLECREDENTIAL_TYPE,\n    ],\n    credentialSubject,\n    proof,\n  };\n}\n","import { mkdir, writeFile, lstat } from 'node:fs/promises';\nimport { join } from 'node:path';\n\nimport { disconnect } from '@kiltprotocol/sdk-js';\n\nimport { configuration } from './utilities/configuration';\nimport {\n  attestDomainLinkage,\n  fromCredential,\n} from './utilities/domainLinkageCredential';\n\n(async () => {\n  console.log(\n    `Generating the .well-known/did-configuration.json file for DID ${configuration.did} and host ${configuration.baseUri}`,\n  );\n\n  const wellKnown = join(configuration.distFolder, 'user', '.well-known');\n  try {\n    await lstat(wellKnown);\n  } catch (error) {\n    console.warn(\n      'Looks like the .well-known folder doesn’t exist, creating',\n      (error as Error).message,\n    );\n    await mkdir(wellKnown);\n  }\n\n  const credential = await attestDomainLinkage();\n  const domainLinkageCredential = fromCredential(credential);\n\n  const didConfigurationResource = {\n    '@context': 'https://identity.foundation/.well-known/did-configuration/v1',\n    linked_dids: [domainLinkageCredential],\n  };\n  const json = JSON.stringify(didConfigurationResource);\n\n  const path = join(wellKnown, 'did-configuration.json');\n  await writeFile(path, json);\n\n  await disconnect();\n})();\n"],"names":["$9PRqK$config","$9a5082739595bce3$var$ConfigurationError","Error","constructor","message","super","$9PRqK$pino","fatal","process","exit","env","$9a5082739595bce3$var$env","$9a5082739595bce3$var$baseUri","URL","$9a5082739595bce3$var$did","DID","$9a5082739595bce3$var$payerMnemonic","SECRET_PAYER_MNEMONIC","$9a5082739595bce3$var$authenticationMnemonic","SECRET_AUTHENTICATION_MNEMONIC","$9a5082739595bce3$var$assertionMethodMnemonic","SECRET_ASSERTION_METHOD_MNEMONIC","$9a5082739595bce3$var$keyAgreementMnemonic","SECRET_KEY_AGREEMENT_MNEMONIC","$9a5082739595bce3$var$blockchainEndpoint","BLOCKCHAIN_ENDPOINT","$9a5082739595bce3$var$adminUsername","ADMIN_USERNAME","$9a5082739595bce3$var$adminPassword","ADMIN_PASSWORD","$9a5082739595bce3$export$1670bf621bbc68f3","port","parseInt","PORT","distFolder","$9PRqK$nodepath","join","$9PRqK$cwd","$9bd0f77a10d65d62$export$cccb07bbeec913a8","$schema","title","properties","id","type","origin","$id","$1749a0affe1e2fac$export$c289742f0747afa3","$9PRqK$cryptoWaitReady","$9PRqK$Utils","Crypto","makeKeypairFromUri","payerMnemonic","authenticationMnemonic","assertionMethodMnemonic","makeEncryptionKeypairFromSeed","mnemonicToMiniSecret","keyAgreementMnemonic","async","$d5e46af1030fd1ba$export$de423f52c8ea922","$9PRqK$connect","blockchainEndpoint","$7e0b7c48c43039ee$var$compareKeys","configured","resolved","relationship","u8aToHex","publicKey","$7e0b7c48c43039ee$export$b8c12ba93511ecc0","did","$9PRqK$Did","resolve","document","fullDid","keypairs","authentication","assertionMethod","keyAgreement","$7e0b7c48c43039ee$var$compareAllKeys","authenticationKey","assertionMethodKey","keyAgreementKey","didDocument","$d04bc697e1db4f68$export$70ace3ca09c7f6b3","data","keyUri","signature","sign","withType","keyType","DEFAULT_VERIFIABLECREDENTIAL_CONTEXT","$556d76faa955485f$var$DEFAULT_VERIFIABLECREDENTIAL_CONTEXT","DEFAULT_VERIFIABLECREDENTIAL_TYPE","$556d76faa955485f$var$DEFAULT_VERIFIABLECREDENTIAL_TYPE","KILT_SELF_SIGNED_PROOF_TYPE","$556d76faa955485f$var$KILT_SELF_SIGNED_PROOF_TYPE","KILT_VERIFIABLECREDENTIAL_TYPE","$556d76faa955485f$var$KILT_VERIFIABLECREDENTIAL_TYPE","$9PRqK$constants","$556d76faa955485f$var$context","$556d76faa955485f$export$aa4a2bb7047c5b07","claimContents","baseUri","claim","$9PRqK$Claim","fromCTypeAndClaimContents","credential","$9PRqK$Credential","fromClaim","createPresentation","signCallback","$556d76faa955485f$export$fe5cb8c82142e82","input","credentialSubject","contents","rootHash","issuer","owner","issuanceDate","Date","toISOString","expirationDate","now","claimerSignature","proof","proofPurpose","verificationMethod","challenge","console","log","wellKnown","$9PRqK$join","$9PRqK$lstat","error","warn","$9PRqK$mkdir","didConfigurationResource","linked_dids","json","JSON","stringify","path","$9PRqK$writeFile","$9PRqK$disconnect"],"version":3,"file":"createDIDConfiguration.js.map","sourceRoot":"../../"}