{"mappings":"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","sources":["src/backend/utilities/configuration.ts","src/backend/utilities/keypairs.ts","src/backend/utilities/initKilt.ts","src/backend/utilities/didDocument.ts","src/backend/utilities/logger.ts","src/backend/utilities/auth.ts","src/backend/endpoints/paths.ts","src/backend/endpoints/user/truora.ts","src/backend/utilities/credentialStorage.ts","src/backend/utilities/cryptoCallbacks.ts","src/backend/utilities/attest.ts","src/backend/utilities/revoke.ts","src/backend/endpoints/admin/credentials.ts","src/backend/routers/admin.ts","src/backend/endpoints/user/sessionHeader.ts","src/backend/utilities/sessionStorage.ts","src/backend/endpoints/user/pay.ts","src/backend/cTypes/emailCType.ts","src/backend/utilities/supportedCTypes.ts","src/backend/cTypes/twitterCType.ts","src/backend/cTypes/ineCType.ts","src/backend/endpoints/user/requestAttestation.ts","src/backend/endpoints/user/session.ts","src/backend/utilities/encryptMessage.ts","src/backend/endpoints/user/terms.ts","src/backend/routers/user.ts","src/backend/server.ts"],"sourcesContent":["import { cwd } from 'node:process';\nimport path from 'node:path';\n\nimport { config } from 'dotenv';\nimport { pino } from 'pino';\nimport { DidUri } from '@kiltprotocol/sdk-js';\n\nconfig();\n\nclass ConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    pino().fatal(message);\n    process.exit(1);\n  }\n}\n\nconst { env } = process;\n\nconst baseUri = env.URL;\nif (!baseUri) {\n  throw new ConfigurationError('URL is not provided');\n}\n\nconst did = env.DID as DidUri;\n\nconst payerMnemonic = env.SECRET_PAYER_MNEMONIC;\nif (!payerMnemonic) {\n  throw new ConfigurationError('SECRET_PAYER_MNEMONIC is not provided');\n}\nconst authenticationMnemonic = env.SECRET_AUTHENTICATION_MNEMONIC;\nif (!authenticationMnemonic) {\n  throw new ConfigurationError(\n    'SECRET_AUTHENTICATION_MNEMONIC is not provided',\n  );\n}\nconst assertionMethodMnemonic = env.SECRET_ASSERTION_METHOD_MNEMONIC;\nif (!assertionMethodMnemonic) {\n  throw new ConfigurationError(\n    'SECRET_ASSERTION_METHOD_MNEMONIC is not provided',\n  );\n}\nconst keyAgreementMnemonic = env.SECRET_KEY_AGREEMENT_MNEMONIC;\nif (!keyAgreementMnemonic) {\n  throw new ConfigurationError('SECRET_KEY_AGREEMENT_MNEMONIC is not provided');\n}\n\nconst blockchainEndpoint = env.BLOCKCHAIN_ENDPOINT;\nif (!blockchainEndpoint) {\n  throw new ConfigurationError('No blockchain endpoint provided');\n}\n\nconst adminUsername = env.ADMIN_USERNAME;\nconst adminPassword = env.ADMIN_PASSWORD;\nif (!adminUsername || !adminPassword) {\n  throw new ConfigurationError('Admin credentials missing');\n}\n\nexport const configuration = {\n  port: parseInt(env.PORT as string) || 3000,\n  blockchainEndpoint,\n  baseUri,\n  distFolder: path.join(cwd(), 'dist', 'frontend'),\n  did,\n  payerMnemonic,\n  authenticationMnemonic,\n  assertionMethodMnemonic,\n  keyAgreementMnemonic,\n  adminUsername,\n  adminPassword,\n};\n","import { Utils } from '@kiltprotocol/sdk-js';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nimport { configuration } from './configuration';\n\nexport const keypairsPromise = (async () => {\n  await cryptoWaitReady();\n\n  const payer = Utils.Crypto.makeKeypairFromUri(configuration.payerMnemonic);\n\n  const authentication = Utils.Crypto.makeKeypairFromUri(\n    configuration.authenticationMnemonic,\n  );\n\n  const assertionMethod = Utils.Crypto.makeKeypairFromUri(\n    configuration.assertionMethodMnemonic,\n  );\n\n  const keyAgreement = Utils.Crypto.makeEncryptionKeypairFromSeed(\n    Utils.Crypto.mnemonicToMiniSecret(configuration.keyAgreementMnemonic),\n  );\n\n  return {\n    payer,\n    authentication,\n    assertionMethod,\n    keyAgreement,\n  };\n})();\n","import { connect } from '@kiltprotocol/sdk-js';\n\nimport { configuration } from './configuration';\n\nexport async function initKilt(): Promise<void> {\n  await connect(configuration.blockchainEndpoint);\n}\n","import type { DidDocument, KeyRelationship } from '@kiltprotocol/sdk-js';\nimport { Did, Utils } from '@kiltprotocol/sdk-js';\n\nimport { keypairsPromise } from './keypairs';\nimport { configuration } from './configuration';\nimport { initKilt } from './initKilt';\n\nasync function compareKeys(\n  configured: { publicKey: Uint8Array },\n  resolved: { publicKey: Uint8Array } | undefined,\n  relationship: KeyRelationship,\n): Promise<void> {\n  if (!resolved) {\n    throw new Error(\n      `Your on-chain DID is broken: the resolved key for ${relationship} is undefined`,\n    );\n  }\n\n  const derivedHex = Utils.Crypto.u8aToHex(configured.publicKey);\n  const resolvedHex = Utils.Crypto.u8aToHex(resolved.publicKey);\n\n  if (derivedHex !== resolvedHex) {\n    throw new Error(\n      `Your on-chain DID is broken: the configured key for ${relationship} does not match resolved one`,\n    );\n  }\n}\n\nasync function compareAllKeys(fullDid: DidDocument): Promise<void> {\n  const keypairs = await keypairsPromise;\n\n  await compareKeys(\n    keypairs.authentication,\n    fullDid.authentication[0],\n    'authentication',\n  );\n  await compareKeys(\n    keypairs.assertionMethod,\n    fullDid.assertionMethod?.[0],\n    'assertionMethod',\n  );\n  await compareKeys(\n    keypairs.keyAgreement,\n    fullDid.keyAgreement?.[0],\n    'keyAgreement',\n  );\n}\n\nexport const didDocumentPromise = (async () => {\n  await initKilt();\n\n  const { did } = configuration;\n  if (!did) {\n    throw new Error('DID not configured, have you run createDID script?');\n  }\n\n  const resolved = await Did.resolve(did);\n  if (!resolved || !resolved.document) {\n    throw new Error(\n      `Could not resolve the configured DID ${did}, have you run createDID script?`,\n    );\n  }\n\n  const { document } = resolved;\n  await compareAllKeys(document);\n\n  const authenticationKey = document.authentication?.[0];\n  if (!authenticationKey) {\n    throw new Error('Impossible: authentication key not found');\n  }\n\n  const assertionMethodKey = document.assertionMethod?.[0];\n  if (!assertionMethodKey) {\n    throw new Error('Impossible: assertion method key not found');\n  }\n\n  const keyAgreementKey = document.keyAgreement?.[0];\n  if (!keyAgreementKey) {\n    throw new Error('Impossible: key agreement key not found');\n  }\n\n  return {\n    did,\n    didDocument: document,\n    authenticationKey,\n    assertionMethodKey,\n    keyAgreementKey,\n  };\n})();\n","import { pino } from 'pino';\nimport pretty from 'pino-pretty';\n\nconst stream = pretty({\n  levelFirst: true,\n  colorize: true,\n  ignore: 'time,hostname,pid',\n});\n\nexport const logger = pino(\n  {\n    level: 'trace',\n  },\n  stream,\n);\n","import basicAuth from 'express-basic-auth';\nimport { configuration } from './configuration';\n\nconst { adminUsername, adminPassword } = configuration;\n\nexport const auth = basicAuth({\n  users: { [adminUsername]: adminPassword },\n  challenge: true,\n});\n","export const paths = {\n  session: '/api/session',\n  terms: '/api/terms',\n  requestAttestation: '/api/request-attestation',\n  pay: '/api/pay',\n\n  // admin\n  credentials: {\n    list: '/api/credentials',\n    item: '/api/credentials/:id',\n    attest: '/api/credentials/:id/attest',\n    revoke: '/api/credentials/:id/revoke',\n  },\n};\n","/* eslint-disable import/no-extraneous-dependencies */\nimport { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { initializeApp, getApps } from 'firebase/app';\n\nimport { getFirestore, doc, setDoc } from 'firebase/firestore';\nimport axios from 'axios';\n\nimport { logger } from '../../utilities/logger';\n\nconst firebaseConfig = {\n  apiKey: 'AIzaSyAAwR5GvEUi3lLWy9bb1tz65jhvHI3vufc',\n  authDomain: 'peranto-test.firebaseapp.com',\n  projectId: 'peranto-test',\n  storageBucket: 'peranto-test.appspot.com',\n  messagingSenderId: '777447831295',\n  appId: '1:777447831295:web:6a987d7c8b307ecef43eca',\n};\n\nconst apps = getApps();\n\nexport const firebase =\n  apps.length > 0 ? apps[0] : initializeApp(firebaseConfig);\n\nexport const firestore = getFirestore(firebase);\n\n// WH SECRET oEI07pv3tHbQ1069H61r35C0K\nasync function handler(req: Request, res: Response): Promise<void> {\n  try {\n    const { accountId, validationId } = req.body;\n\n    const { data } = await axios.get(\n      `https://api.validations.truora.com/v1/validations/${validationId}`,\n      {\n        headers: {\n          'Truora-API-Key':\n            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2NvdW50X2lkIjoiIiwiYWRkaXRpb25hbF9kYXRhIjoie30iLCJjbGllbnRfaWQiOiJUQ0llNTEwMjRiOTlmN2YwZDc2NzZhYTFlOGI1NWY3YmI4MiIsImV4cCI6MzI2NTQ3OTQ2MywiZ3JhbnQiOiIiLCJpYXQiOjE2ODg2Nzk0NjMsImlzcyI6Imh0dHBzOi8vY29nbml0by1pZHAudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vdXMtZWFzdC0xX1lZY2VRNXlxSSIsImp0aSI6ImVkMzZhMGQwLTYxYjgtNDQ0Ni04OWNmLWFiNDEwYWY5NDkyNCIsImtleV9uYW1lIjoicGVyYW50b3Rlc3QiLCJrZXlfdHlwZSI6ImJhY2tlbmQiLCJ1c2VybmFtZSI6InBlcmFudG9zZXJ2aWNlcy1wZXJhbnRvdGVzdCJ9.gVB8petsqNJAmwSUUF8AKwzx8UUezTpyqrsEIH36ses',\n        },\n      },\n    );\n\n    const docRef = await setDoc(\n      doc(firestore, 'truora', 'testId_' + validationId),\n      {\n        ...data,\n        accountId,\n        validationId,\n      },\n    );\n\n    res.json({\n      docRef,\n    });\n  } catch (error) {\n    logger.error(error);\n\n    res.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const truora = Router();\n\ntruora.post('/api/truora', handler);\n","/* eslint-disable import/no-extraneous-dependencies */\nimport { randomUUID } from 'node:crypto';\n\nimport { IAttestation, ICredential } from '@kiltprotocol/sdk-js';\nimport {\n  doc,\n  setDoc,\n  getDocs,\n  getDoc,\n  collection,\n  updateDoc,\n  deleteDoc,\n} from 'firebase/firestore';\nimport { firestore } from '../endpoints/user/truora';\n\nexport class NotFoundError extends Error {}\n\nexport interface Credential {\n  claim: ICredential;\n  attestation?: IAttestation;\n}\n\n// Maps are used for example purposes. A real database should be used in production.\n// const credentials: Map<string, Credential> = new Map();\n\nexport function addClaim(claim: ICredential) {\n  const id = randomUUID();\n  // credentials.set(id, { claim });\n\n  setDoc(doc(firestore, 'credentials', id), { claim });\n}\n\nexport async function listCredentials() {\n  // return Object.fromEntries(credentials.entries());\n\n  let result: any = {};\n  const docs = await getDocs(collection(firestore, 'credentials'));\n\n  docs.forEach((doc) => {\n    result = { ...result, [doc.id]: { ...doc.data(), id: doc.id } };\n  });\n\n  return result;\n}\n\nexport async function getCredential(id: string) {\n  // const credential = credentials.get(id);\n  const _doc = await getDoc(doc(firestore, 'credentials', id));\n  const credential = { ..._doc.data(), id };\n\n  if (!credential) {\n    throw new NotFoundError('Credential not found');\n  }\n\n  return credential;\n}\n\nexport async function deleteCredential(id: string) {\n  await deleteDoc(doc(firestore, 'credentials', id));\n\n  // const deleted = credentials.delete(id);\n  // if (!deleted) {\n  //   throw new NotFoundError('Credential not found');\n  // }\n}\n\nexport async function addAttestation(id: string, attestation: IAttestation) {\n  const credential = await getCredential(id);\n\n  // credentials.set(id, { ...credential, attestation });\n  await updateDoc(doc(firestore, 'credentials', id), {\n    ...credential,\n    attestation,\n  });\n\n  return await getCredential(id);\n}\n","import {\n  DecryptCallback,\n  DidResourceUri,\n  EncryptCallback,\n  SignRequestData,\n  Utils,\n} from '@kiltprotocol/sdk-js';\n\nimport { keypairsPromise } from './keypairs';\nimport { didDocumentPromise } from './didDocument';\n\nexport async function sign({ data, keyRelationship }: SignRequestData) {\n  if (keyRelationship === 'capabilityDelegation') {\n    throw new Error('Delegation not supported');\n  }\n  const { authentication, assertionMethod } = await keypairsPromise;\n  const { did, authenticationKey, assertionMethodKey } =\n    await didDocumentPromise;\n\n  const [keypair, publicKey] =\n    keyRelationship === 'authentication'\n      ? [authentication, authenticationKey]\n      : [assertionMethod, assertionMethodKey];\n\n  const keyUri: DidResourceUri = `${did}${publicKey.id}`;\n\n  return {\n    signature: keypair.sign(data, { withType: false }),\n    keyType: keypair.type,\n    keyUri,\n  };\n}\n\nexport async function signWithAssertionMethod({ data }: { data: Uint8Array }) {\n  const { assertionMethod } = await keypairsPromise;\n\n  const { did, assertionMethodKey } = await didDocumentPromise;\n  const keyUri: DidResourceUri = `${did}${assertionMethodKey.id}`;\n\n  return {\n    signature: assertionMethod.sign(data, { withType: false }),\n    keyType: assertionMethod.type,\n    keyUri,\n  };\n}\n\nexport async function encrypt({\n  data,\n  peerPublicKey,\n}: Parameters<EncryptCallback>[0]) {\n  const { keyAgreement } = await keypairsPromise;\n\n  const { did, keyAgreementKey } = await didDocumentPromise;\n  const keyUri: DidResourceUri = `${did}${keyAgreementKey.id}`;\n\n  const { box, nonce } = Utils.Crypto.encryptAsymmetric(\n    data,\n    peerPublicKey,\n    keyAgreement.secretKey,\n  );\n\n  return {\n    data: box,\n    nonce,\n    keyUri,\n  };\n}\n\nexport async function decrypt({\n  data: box,\n  nonce,\n  peerPublicKey,\n}: Parameters<DecryptCallback>[0]) {\n  const { keyAgreement } = await keypairsPromise;\n\n  const data = Utils.Crypto.decryptAsymmetric(\n    { box, nonce },\n    peerPublicKey,\n    keyAgreement.secretKey,\n  );\n  if (!data) {\n    throw new Error('Failed to decrypt with given key');\n  }\n\n  return {\n    data,\n  };\n}\n","import {\n  Attestation,\n  Blockchain,\n  ConfigService,\n  Did,\n  IAttestation,\n  ICredential,\n} from '@kiltprotocol/sdk-js';\nimport { configuration } from './configuration';\nimport { sign } from './cryptoCallbacks';\nimport { keypairsPromise } from './keypairs';\n\nexport async function attest(credential: ICredential): Promise<IAttestation> {\n  const api = ConfigService.get('api');\n\n  const attestation = Attestation.fromCredentialAndDid(\n    credential,\n    configuration.did,\n  );\n\n  const { claimHash, cTypeHash } = attestation;\n\n  const { payer } = await keypairsPromise;\n\n  const tx = api.tx.attestation.add(claimHash, cTypeHash, null);\n  const authorized = await Did.authorizeTx(\n    configuration.did,\n    tx,\n    sign,\n    payer.address,\n  );\n\n  await Blockchain.signAndSubmitTx(authorized, payer);\n\n  return attestation;\n}\n","import {\n  Attestation,\n  Blockchain,\n  ConfigService,\n  Did,\n  ICredential,\n} from '@kiltprotocol/sdk-js';\nimport { configuration } from './configuration';\nimport { sign } from './cryptoCallbacks';\nimport { keypairsPromise } from './keypairs';\n\nexport async function revoke(credential: ICredential) {\n  const api = ConfigService.get('api');\n  const { rootHash } = credential;\n\n  const tx = api.tx.attestation.revoke(rootHash, null);\n\n  const { payer } = await keypairsPromise;\n\n  const authorized = await Did.authorizeTx(\n    configuration.did,\n    tx,\n    sign,\n    payer.address,\n  );\n\n  await Blockchain.signAndSubmitTx(authorized, payer);\n\n  const attestation = await api.query.attestation.attestations(rootHash);\n\n  return Attestation.fromChain(attestation, rootHash);\n}\n","import { Response, Router } from 'express';\n\nimport { paths } from '../paths';\nimport {\n  NotFoundError,\n  deleteCredential,\n  getCredential,\n  listCredentials,\n  addAttestation,\n} from '../../utilities/credentialStorage';\nimport { StatusCodes } from 'http-status-codes';\nimport { logger } from '../../utilities/logger';\nimport { attest } from '../../utilities/attest';\nimport { revoke } from '../../utilities/revoke';\n\nfunction sendErrorResponse(error: unknown, response: Response) {\n  logger.error(error);\n  if (error instanceof NotFoundError) {\n    response.status(StatusCodes.NOT_FOUND).send(error);\n  } else {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const credentials = Router();\n// Trigger deploy\n\ncredentials.get(paths.credentials.list, async (request, response) => {\n  logger.debug('Getting list of credentials');\n  response.send(await listCredentials());\n});\n\ncredentials.get(paths.credentials.item, async (request, response) => {\n  try {\n    const { id } = request.params;\n\n    logger.debug(`Getting credential`);\n\n    response.send(await getCredential(id));\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n\ncredentials.delete(paths.credentials.item, async (request, response) => {\n  try {\n    const { id } = request.params;\n    logger.debug('Deleting credential');\n\n    await deleteCredential(id);\n\n    response.sendStatus(StatusCodes.OK);\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n\ncredentials.post(paths.credentials.attest, async (request, response) => {\n  try {\n    const { id } = request.params;\n\n    logger.debug(`Getting credential`);\n    const { claim } = (await getCredential(id)) as any;\n\n    logger.debug('Attesting credential');\n    const attestation = await attest(claim);\n\n    logger.debug('Credential attested, updating database');\n    const attestedCredential = await addAttestation(id, attestation);\n\n    response.send(attestedCredential);\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n\ncredentials.post(paths.credentials.revoke, async (request, response) => {\n  try {\n    const { id } = request.params;\n\n    logger.debug('Getting credential');\n    const { claim } = (await getCredential(id)) as any;\n\n    logger.debug('Revoking credential');\n    const attestation = await revoke(claim);\n\n    logger.debug('Credential revoked, updating database');\n    const revokedCredential = await addAttestation(id, attestation);\n\n    response.send(revokedCredential);\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n","import express, { Router } from 'express';\nimport { configuration } from '../utilities/configuration';\n\nimport { credentials } from '../endpoints/admin/credentials';\n\nexport const adminRouter = Router();\n\nadminRouter.use(credentials);\n\nadminRouter.use(\n  // eslint-disable-next-line import/no-named-as-default-member\n  express.static(`${configuration.distFolder}/admin`, {\n    dotfiles: 'allow',\n    setHeaders(res) {\n      res.set('Access-Control-Allow-Origin', '*');\n    },\n  }),\n);\n\nadminRouter.get('*', (request, response) => {\n  response.sendFile(`${configuration.distFolder}/admin/index.html`);\n});\n","export const sessionHeader = 'x-session-id';\n","import { NextFunction, Request, Response } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport NodeCache from 'node-cache';\nimport { DidResourceUri, DidUri, ICredential } from '@kiltprotocol/sdk-js';\n\nimport { sessionHeader } from '../endpoints/user/sessionHeader';\n\nexport interface BasicSession {\n  sessionId: string;\n  did?: DidUri;\n  encryptionKeyUri?: DidResourceUri;\n  didChallenge?: string;\n  didConfirmed?: boolean;\n  credential?: ICredential;\n}\n\nexport type Session = BasicSession & {\n  did: DidUri;\n  encryptionKeyUri: DidResourceUri;\n};\n\nconst sessionStorage = new NodeCache({ stdTTL: 5 * 60 * 60, useClones: false });\n\nfunction getSessionById(sessionId: string): BasicSession {\n  const session = sessionStorage.get(sessionId);\n  if (!session) {\n    throw new Error(`Unknown or expired session ${sessionId}`);\n  }\n  return session as BasicSession;\n}\n\nfunction getBasicSession(request: Request): BasicSession {\n  const sessionId = request.get(sessionHeader);\n\n  if (!sessionId) {\n    throw new Error(`Required header ${sessionHeader} is missing`);\n  }\n\n  return getSessionById(sessionId);\n}\n\nfunction getSession(request: Request): Session {\n  const session = getBasicSession(request);\n\n  const { did, didConfirmed, encryptionKeyUri } = session;\n  if (!did || !didConfirmed || !encryptionKeyUri) {\n    throw new Error('Unconfirmed DID');\n  }\n\n  return { ...session, did, encryptionKeyUri };\n}\n\nexport function setSession(session: BasicSession): void {\n  sessionStorage.set(session.sessionId, session);\n}\n\nexport function basicSessionMiddleware(\n  request: Request,\n  response: Response,\n  next: NextFunction,\n): void {\n  try {\n    const session = getBasicSession(request);\n    (request as Request & { session: BasicSession }).session = session;\n    next();\n  } catch (error) {\n    response.status(StatusCodes.FORBIDDEN).send(error);\n  }\n}\n\nexport function sessionMiddleware(\n  request: Request,\n  response: Response,\n  next: NextFunction,\n): void {\n  try {\n    const session = getSession(request);\n    (request as Request & { session: Session }).session = session;\n    next();\n  } catch (error) {\n    response.status(StatusCodes.FORBIDDEN).send(error);\n  }\n}\n","import { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { logger } from '../../utilities/logger';\nimport { Session, sessionMiddleware } from '../../utilities/sessionStorage';\nimport { paths } from '../paths';\nimport { addClaim } from '../../utilities/credentialStorage';\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  // implement your payment logic here\n\n  try {\n    logger.debug('Mock processing payment');\n\n    const {\n      session: { credential },\n    } = request as Request & { session: Session };\n\n    if (!credential) {\n      throw new Error('Session credential not found');\n    }\n\n    addClaim(credential);\n\n    logger.debug('Payment received, sent credential to attester');\n    response.sendStatus(StatusCodes.NO_CONTENT);\n  } catch (error) {\n    logger.error(error);\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const pay = Router();\n\npay.post(paths.pay, sessionMiddleware, handler);\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const emailCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'Email',\n  properties: {\n    Email: {\n      type: 'string',\n    },\n  },\n  type: 'object',\n  $id: 'kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac',\n};\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nimport { emailCType } from '../cTypes/emailCType';\nimport { twitterCType } from '../cTypes/twitterCType';\nimport { ineCType } from '../cTypes/ineCType';\n\nexport const supportedCTypeKeys = ['email', 'twitter', 'id'] as const;\n\nexport type SupportedCType = (typeof supportedCTypeKeys)[number];\n\nexport const supportedCTypes: Record<SupportedCType, ICType> = {\n  email: emailCType,\n  twitter: twitterCType,\n  id: ineCType,\n};\n\nexport const kiltCost: Record<SupportedCType, number> = {\n  id: 2,\n  email: 2,\n  twitter: 3,\n};\n\nexport function isSupportedCType(cType: string): cType is SupportedCType {\n  return supportedCTypeKeys.includes(cType as SupportedCType);\n}\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const twitterCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'Twitter',\n  properties: {\n    Twitter: {\n      type: 'string',\n    },\n  },\n  type: 'object',\n  $id: 'kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420',\n};\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const ineCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  properties: {\n    email: {\n      type: 'string',\n    },\n    username: {\n      type: 'string',\n    },\n  },\n  title: 'Authorization',\n  type: 'object',\n  $id: 'kilt:ctype:0xdf952230c87e7fbdc8503a394540c8e99029180611e7107c4eee33f67f57aa57',\n};\n","import { Credential, CType, Message, Quote } from '@kiltprotocol/sdk-js';\nimport { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { decrypt } from '../../utilities/cryptoCallbacks';\nimport { logger } from '../../utilities/logger';\nimport {\n  Session,\n  sessionMiddleware,\n  setSession,\n} from '../../utilities/sessionStorage';\nimport { supportedCTypes } from '../../utilities/supportedCTypes';\nimport { paths } from '../paths';\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  try {\n    logger.debug('Handling attestation request');\n\n    const message = await Message.decrypt(request.body, decrypt);\n    const messageBody = message.body;\n    logger.debug('Request attestation message decrypted');\n\n    Message.verifyMessageBody(messageBody);\n    const { type } = messageBody;\n\n    if (type === 'reject' || type === 'reject-terms') {\n      response.status(StatusCodes.CONFLICT).send('Message contains rejection');\n      return;\n    }\n\n    if (type !== 'request-attestation') {\n      throw new Error('Unexpected message type');\n    }\n\n    const { quote, credential } = messageBody.content;\n\n    if (quote) {\n      await Quote.verifyQuoteAgreement(quote);\n      logger.debug('Quote agreement verified');\n    }\n\n    const cTypes = Object.values(supportedCTypes);\n    const cTypeId = CType.hashToId(credential.claim.cTypeHash);\n    const ctype = cTypes.find(({ $id }) => $id === cTypeId);\n    if (!ctype) {\n      response.status(StatusCodes.FORBIDDEN).send('Unsupported CType');\n    }\n    logger.debug('CType supported');\n\n    await Credential.verifyWellFormed(credential, { ctype });\n    logger.debug('Credential data structure verified');\n\n    const { session } = request as Request & { session: Session };\n    setSession({ ...session, credential });\n\n    logger.debug('Request attestation complete');\n    response.sendStatus(StatusCodes.NO_CONTENT);\n  } catch (error) {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const requestAttestation = Router();\n\nrequestAttestation.post(paths.requestAttestation, sessionMiddleware, handler);\n","import { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\n\nimport { Did, DidResourceUri, Utils } from '@kiltprotocol/sdk-js';\nimport { randomAsHex } from '@polkadot/util-crypto';\n\nimport { didDocumentPromise } from '../../utilities/didDocument';\nimport { decrypt } from '../../utilities/cryptoCallbacks';\nimport {\n  BasicSession,\n  basicSessionMiddleware,\n  setSession,\n} from '../../utilities/sessionStorage';\nimport { logger } from '../../utilities/logger';\n\nimport { paths } from '../paths';\n\nexport interface CheckSessionInput {\n  encryptionKeyUri: DidResourceUri;\n  encryptedChallenge: string;\n  nonce: string;\n}\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  try {\n    logger.debug('Session confirmation started');\n\n    const payload = request.body as CheckSessionInput;\n    const { encryptionKeyUri, encryptedChallenge, nonce } = payload;\n    const { session } = request as Request & { session: BasicSession };\n\n    const encryptionKey = await Did.resolveKey(encryptionKeyUri);\n\n    logger.debug('Session confirmation resolved DID encryption key');\n\n    const { keyAgreementKey, did } = await didDocumentPromise;\n\n    const { data } = await decrypt({\n      data: Utils.Crypto.coToUInt8(encryptedChallenge),\n      nonce: Utils.Crypto.coToUInt8(nonce),\n      keyUri: `${did}${keyAgreementKey.id}`,\n      peerPublicKey: encryptionKey.publicKey,\n    });\n    logger.debug('Session confirmation decrypted challenge');\n\n    const decryptedChallenge = Utils.Crypto.u8aToHex(data);\n    const originalChallenge = session.didChallenge;\n\n    if (decryptedChallenge !== originalChallenge) {\n      response\n        .status(StatusCodes.FORBIDDEN)\n        .send('Challenge signature mismatch');\n      return;\n    }\n\n    setSession({\n      ...session,\n      did: encryptionKey.controller,\n      encryptionKeyUri,\n      didConfirmed: true,\n    });\n\n    logger.debug('Challenge confirmation matches');\n    response.sendStatus(StatusCodes.NO_CONTENT);\n  } catch (error) {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nfunction startSession() {\n  const sessionId = randomAsHex(24);\n  const challenge = randomAsHex(24);\n\n  setSession({ sessionId, didChallenge: challenge });\n\n  return {\n    challenge,\n    sessionId,\n  };\n}\n\nexport interface GetSessionOutput {\n  dAppEncryptionKeyUri: DidResourceUri;\n  sessionId: string;\n  challenge: string;\n}\n\nconst path = paths.session;\n\nexport const session = Router();\n\nsession.get(path, async (request, response) => {\n  const { did, keyAgreementKey } = await didDocumentPromise;\n  const dAppEncryptionKeyUri: DidResourceUri = `${did}${keyAgreementKey.id}`;\n  response.send({\n    dAppEncryptionKeyUri,\n    ...startSession(),\n  } as GetSessionOutput);\n});\n\nsession.post(path, basicSessionMiddleware, handler);\n","import type {\n  DidResourceUri,\n  IEncryptedMessage,\n  MessageBody,\n} from '@kiltprotocol/sdk-js';\nimport { Did, Message } from '@kiltprotocol/sdk-js';\n\nimport { encrypt } from './cryptoCallbacks';\nimport { configuration } from './configuration';\n\nexport async function encryptMessageBody(\n  encryptionKeyUri: DidResourceUri,\n  messageBody: MessageBody,\n): Promise<IEncryptedMessage> {\n  const { did } = Did.parse(encryptionKeyUri);\n\n  const message = Message.fromBody(messageBody, configuration.did, did);\n  return Message.encrypt(message, encrypt, encryptionKeyUri);\n}\n","import { Claim, IClaimContents, IQuote, Quote } from '@kiltprotocol/sdk-js';\nimport { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { configuration } from '../../utilities/configuration';\nimport { sign } from '../../utilities/cryptoCallbacks';\nimport { encryptMessageBody } from '../../utilities/encryptMessage';\nimport { logger } from '../../utilities/logger';\nimport { Session, sessionMiddleware } from '../../utilities/sessionStorage';\nimport {\n  kiltCost,\n  SupportedCType,\n  supportedCTypes,\n} from '../../utilities/supportedCTypes';\nimport { paths } from '../paths';\n\nconst TTL = 5 * 60 * 60 * 1000;\nconst TERMS = 'https://example.com/terms-and-conditions';\n\ninterface Input {\n  type: SupportedCType;\n  claimContents: IClaimContents;\n}\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  try {\n    logger.debug('Submit terms started');\n\n    const { session } = request as Request & { session: Session };\n    const { encryptionKeyUri } = session;\n\n    const { type, claimContents } = request.body as Input;\n\n    logger.info('ctype: ' + JSON.stringify(supportedCTypes[type]));\n    const claim = Claim.fromCTypeAndClaimContents(\n      supportedCTypes[type],\n      claimContents,\n      session.did,\n    );\n    logger.debug('Generated claim');\n\n    const quote: IQuote = {\n      attesterDid: configuration.did,\n      cTypeHash: claim.cTypeHash,\n      cost: { tax: { VAT: 0 }, net: kiltCost[type], gross: kiltCost[type] },\n      currency: 'KILT',\n      timeframe: new Date(Date.now() + TTL).toISOString(),\n      termsAndConditions: TERMS,\n    };\n\n    const signedQuote = await Quote.createAttesterSignedQuote(quote, sign);\n    logger.debug('Signed quote');\n\n    const output = await encryptMessageBody(encryptionKeyUri, {\n      content: {\n        claim,\n        legitimations: [],\n        quote: signedQuote,\n        cTypes: [supportedCTypes[type]],\n      },\n      type: 'submit-terms',\n    });\n    logger.debug('Submit terms complete');\n    response.send(output);\n  } catch (error) {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\nexport const terms = Router();\n\nterms.post(paths.terms, sessionMiddleware, handler);\n","import express, { Router } from 'express';\n\nimport { pay } from '../endpoints/user/pay';\nimport { requestAttestation } from '../endpoints/user/requestAttestation';\nimport { session } from '../endpoints/user/session';\nimport { terms } from '../endpoints/user/terms';\nimport { truora } from '../endpoints/user/truora';\n\nimport { configuration } from '../utilities/configuration';\n\nexport const userRouter = Router();\n\nuserRouter.use(session);\nuserRouter.use(terms);\nuserRouter.use(requestAttestation);\nuserRouter.use(pay);\nuserRouter.use(truora);\n\nuserRouter.use(\n  // eslint-disable-next-line import/no-named-as-default-member\n  express.static(`${configuration.distFolder}/user`, {\n    dotfiles: 'allow',\n    setHeaders(res) {\n      res.set('Access-Control-Allow-Origin', '*');\n    },\n  }),\n);\n\nuserRouter.get('*', (request, response) => {\n  response.sendFile(`${configuration.distFolder}/user/index.html`);\n});\n","import express from 'express';\nimport bodyParser from 'body-parser';\n\nimport { didDocumentPromise } from './utilities/didDocument';\nimport { configuration } from './utilities/configuration';\nimport { logger } from './utilities/logger';\n\nimport { auth } from './utilities/auth';\nimport { adminRouter } from './routers/admin';\nimport { userRouter } from './routers/user';\n\nconst initApp = async () => {\n  await didDocumentPromise;\n  logger.info('Blockchain connection initialized');\n\n  const app = express();\n  app.use(bodyParser.json());\n\n  app.use('/admin', auth, adminRouter);\n  app.use('/', userRouter);\n\n  logger.info('Routes configured');\n\n  const host = '0.0.0.0';\n  const { port, baseUri } = configuration;\n  const started = app.listen(port, host, () =>\n    logger.info(`Listening on ${baseUri} (host: ${host}, port: ${port})`),\n  );\n\n  function stop() {\n    started.close();\n    process.exit(1);\n  }\n\n  process.on('unhandledRejection', stop);\n  process.on('uncaughtException', stop);\n\n  return app;\n};\n\nexport default initApp();\n"],"names":["$8li2e$config","$9a5082739595bce3$var$ConfigurationError","Error","constructor","message","super","$8li2e$pino","fatal","process","exit","env","$9a5082739595bce3$var$env","$9a5082739595bce3$var$baseUri","URL","$9a5082739595bce3$var$did","DID","$9a5082739595bce3$var$payerMnemonic","SECRET_PAYER_MNEMONIC","$9a5082739595bce3$var$authenticationMnemonic","SECRET_AUTHENTICATION_MNEMONIC","$9a5082739595bce3$var$assertionMethodMnemonic","SECRET_ASSERTION_METHOD_MNEMONIC","$9a5082739595bce3$var$keyAgreementMnemonic","SECRET_KEY_AGREEMENT_MNEMONIC","$9a5082739595bce3$var$blockchainEndpoint","BLOCKCHAIN_ENDPOINT","$9a5082739595bce3$var$adminUsername","ADMIN_USERNAME","$9a5082739595bce3$var$adminPassword","ADMIN_PASSWORD","$9a5082739595bce3$export$1670bf621bbc68f3","port","parseInt","PORT","distFolder","$8li2e$nodepath","join","$8li2e$cwd","$1749a0affe1e2fac$export$c289742f0747afa3","$8li2e$cryptoWaitReady","$8li2e$Utils","Crypto","makeKeypairFromUri","payerMnemonic","authenticationMnemonic","assertionMethodMnemonic","makeEncryptionKeypairFromSeed","mnemonicToMiniSecret","keyAgreementMnemonic","async","$d5e46af1030fd1ba$export$de423f52c8ea922","$8li2e$connect","blockchainEndpoint","$7e0b7c48c43039ee$var$compareKeys","configured","resolved","relationship","u8aToHex","publicKey","$7e0b7c48c43039ee$export$b8c12ba93511ecc0","did","$8li2e$Did","resolve","document","fullDid","keypairs","authentication","assertionMethod","keyAgreement","$7e0b7c48c43039ee$var$compareAllKeys","authenticationKey","assertionMethodKey","keyAgreementKey","didDocument","$15a6ac0367590b47$var$stream","$8li2e$pinopretty","levelFirst","colorize","ignore","$15a6ac0367590b47$export$af88d00dbe7f521","level","adminUsername","$b3dd54d8f90dbc1c$var$adminUsername","adminPassword","$b3dd54d8f90dbc1c$var$adminPassword","$b3dd54d8f90dbc1c$export$73693bad9f5880b0","$8li2e$expressbasicauth","users","challenge","$8b8135ac0a872448$export$595447059867920","session","terms","requestAttestation","pay","credentials","list","item","attest","revoke","$c26919633a7840a8$var$apps","$8li2e$getApps","$c26919633a7840a8$export$e0cb15fb3b8fc489","$8li2e$getFirestore","length","$8li2e$initializeApp","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","$c26919633a7840a8$export$7dd6545160a2ad26","$8li2e$Router","post","req","res","accountId","validationId","body","data","$8li2e$axios","get","headers","docRef","$8li2e$setDoc","$8li2e$doc","json","error","status","$8li2e$StatusCodes","INTERNAL_SERVER_ERROR","send","$18cddce23ffb0b39$export$78c95b58762d2106","$18cddce23ffb0b39$export$fa223408cdeea5e5","claim","id","$8li2e$randomUUID","$18cddce23ffb0b39$export$ae2cee3e11f6a533","result","$8li2e$getDocs","$8li2e$collection","forEach","doc","$18cddce23ffb0b39$export$298c59008c641b3e","credential","$8li2e$getDoc","$18cddce23ffb0b39$export$663b6344735d0e78","$8li2e$deleteDoc","$18cddce23ffb0b39$export$a2813f6973ed113","attestation","$8li2e$updateDoc","$d04bc697e1db4f68$export$c5552dfdbc7cec71","keyRelationship","keypair","keyUri","signature","sign","withType","keyType","type","$d04bc697e1db4f68$export$5b0f6292f11d1d18","peerPublicKey","box","nonce","encryptAsymmetric","secretKey","$d04bc697e1db4f68$export$e85a0c9a1067c5d3","decryptAsymmetric","$ceb6527163e88ac4$export$994159fc52341244","api","$8li2e$ConfigService","$8li2e$Attestation","fromCredentialAndDid","claimHash","cTypeHash","payer","tx","add","authorized","authorizeTx","address","$8li2e$Blockchain","signAndSubmitTx","$7d9c09f48e3eea26$export$573f8dbbf6fbef75","rootHash","query","attestations","fromChain","$3a47d82b8ed8e023$var$sendErrorResponse","response","NOT_FOUND","$3a47d82b8ed8e023$export$78896651422bbf9e","request","debug","params","delete","sendStatus","OK","attestedCredential","revokedCredential","$8dcf704c811bb6ca$export$e73631d91f945400","use","$8li2e$express","static","dotfiles","setHeaders","set","sendFile","$cdebb7d266d5529a$var$sessionStorage","$8li2e$nodecache","stdTTL","useClones","$cdebb7d266d5529a$var$getBasicSession","sessionId","$cdebb7d266d5529a$var$getSessionById","$cdebb7d266d5529a$export$b94982631f8f9752","$cdebb7d266d5529a$export$f484ee341a6e9f8f","next","didConfirmed","encryptionKeyUri","$cdebb7d266d5529a$var$getSession","FORBIDDEN","$fa40543f7f9825c4$export$552d83b9289531dc","NO_CONTENT","$a0a27930e77ba031$export$fceeab0910ee116e","email","$schema","title","properties","Email","$id","twitter","Twitter","username","$a0a27930e77ba031$export$721e075907bcb4ad","$544f4c7c8812f4a4$export$ddf46a4b5b1c2865","$a2666dc51342e5ad$var$startSession","$8li2e$randomAsHex","didChallenge","messageBody","$8li2e$Message","decrypt","verifyMessageBody","CONFLICT","quote","content","$8li2e$Quote","verifyQuoteAgreement","cTypes","Object","values","cTypeId","$8li2e$CType","hashToId","ctype","find","$8li2e$Credential","verifyWellFormed","$a2666dc51342e5ad$var$path","$a2666dc51342e5ad$export$55427e926be628d4","$d6888dba0634184a$export$5a3d317611b281f5","parse","fromBody","encrypt","dAppEncryptionKeyUri","payload","encryptedChallenge","encryptionKey","resolveKey","coToUInt8","decryptedChallenge","controller","$9956318176747e0e$export$8a21ba990ca4a7cb","claimContents","info","JSON","stringify","$8li2e$Claim","fromCTypeAndClaimContents","attesterDid","cost","tax","VAT","net","gross","currency","timeframe","Date","now","toISOString","termsAndConditions","signedQuote","createAttesterSignedQuote","output","legitimations","$9e4614c218229bd5$export$7bb46b7223ebd883","app","$8li2e$bodyparser","host","baseUri","started","listen","stop","close","on","$2dbda6e7de11ca31$var$initApp"],"version":3,"file":"server.js.map","sourceRoot":"../../"}