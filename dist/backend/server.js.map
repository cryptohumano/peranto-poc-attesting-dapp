{"mappings":"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","sources":["src/backend/utilities/configuration.ts","src/backend/utilities/keypairs.ts","src/backend/utilities/initKilt.ts","src/backend/utilities/didDocument.ts","src/backend/utilities/logger.ts","src/backend/utilities/auth.ts","src/backend/endpoints/paths.ts","src/backend/utilities/credentialStorage.ts","src/backend/utilities/cryptoCallbacks.ts","src/backend/utilities/attest.ts","src/backend/utilities/revoke.ts","src/backend/endpoints/admin/credentials.ts","src/backend/routers/admin.ts","src/backend/endpoints/user/sessionHeader.ts","src/backend/utilities/sessionStorage.ts","src/backend/endpoints/user/pay.ts","src/backend/cTypes/emailCType.ts","src/backend/utilities/supportedCTypes.ts","src/backend/cTypes/twitterCType.ts","src/backend/cTypes/idCType.ts","src/backend/endpoints/user/requestAttestation.ts","src/backend/endpoints/user/session.ts","src/backend/utilities/encryptMessage.ts","src/backend/endpoints/user/terms.ts","src/backend/routers/user.ts","src/backend/server.ts"],"sourcesContent":["import { cwd } from 'node:process';\nimport path from 'node:path';\n\nimport { config } from 'dotenv';\nimport { pino } from 'pino';\nimport { DidUri } from '@kiltprotocol/sdk-js';\n\nconfig();\n\nclass ConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    pino().fatal(message);\n    process.exit(1);\n  }\n}\n\nconst { env } = process;\n\nconst baseUri = env.URL;\nif (!baseUri) {\n  throw new ConfigurationError('URL is not provided');\n}\n\nconst did = env.DID as DidUri;\n\nconst payerMnemonic = env.SECRET_PAYER_MNEMONIC;\nif (!payerMnemonic) {\n  throw new ConfigurationError('SECRET_PAYER_MNEMONIC is not provided');\n}\nconst authenticationMnemonic = env.SECRET_AUTHENTICATION_MNEMONIC;\nif (!authenticationMnemonic) {\n  throw new ConfigurationError(\n    'SECRET_AUTHENTICATION_MNEMONIC is not provided',\n  );\n}\nconst assertionMethodMnemonic = env.SECRET_ASSERTION_METHOD_MNEMONIC;\nif (!assertionMethodMnemonic) {\n  throw new ConfigurationError(\n    'SECRET_ASSERTION_METHOD_MNEMONIC is not provided',\n  );\n}\nconst keyAgreementMnemonic = env.SECRET_KEY_AGREEMENT_MNEMONIC;\nif (!keyAgreementMnemonic) {\n  throw new ConfigurationError('SECRET_KEY_AGREEMENT_MNEMONIC is not provided');\n}\n\nconst blockchainEndpoint = env.BLOCKCHAIN_ENDPOINT;\nif (!blockchainEndpoint) {\n  throw new ConfigurationError('No blockchain endpoint provided');\n}\n\nconst adminUsername = env.ADMIN_USERNAME;\nconst adminPassword = env.ADMIN_PASSWORD;\nif (!adminUsername || !adminPassword) {\n  throw new ConfigurationError('Admin credentials missing');\n}\n\nexport const configuration = {\n  port: parseInt(env.PORT as string) || 3000,\n  blockchainEndpoint,\n  baseUri,\n  distFolder: path.join(cwd(), 'dist', 'frontend'),\n  did,\n  payerMnemonic,\n  authenticationMnemonic,\n  assertionMethodMnemonic,\n  keyAgreementMnemonic,\n  adminUsername,\n  adminPassword,\n};\n","import { Utils } from '@kiltprotocol/sdk-js';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nimport { configuration } from './configuration';\n\nexport const keypairsPromise = (async () => {\n  await cryptoWaitReady();\n\n  const payer = Utils.Crypto.makeKeypairFromUri(configuration.payerMnemonic);\n\n  const authentication = Utils.Crypto.makeKeypairFromUri(\n    configuration.authenticationMnemonic,\n  );\n\n  const assertionMethod = Utils.Crypto.makeKeypairFromUri(\n    configuration.assertionMethodMnemonic,\n  );\n\n  const keyAgreement = Utils.Crypto.makeEncryptionKeypairFromSeed(\n    Utils.Crypto.mnemonicToMiniSecret(configuration.keyAgreementMnemonic),\n  );\n\n  return {\n    payer,\n    authentication,\n    assertionMethod,\n    keyAgreement,\n  };\n})();\n","import { connect } from '@kiltprotocol/sdk-js';\n\nimport { configuration } from './configuration';\n\nexport async function initKilt(): Promise<void> {\n  await connect(configuration.blockchainEndpoint);\n}\n","import type { DidDocument, KeyRelationship } from '@kiltprotocol/sdk-js';\nimport { Did, Utils } from '@kiltprotocol/sdk-js';\n\nimport { keypairsPromise } from './keypairs';\nimport { configuration } from './configuration';\nimport { initKilt } from './initKilt';\n\nasync function compareKeys(\n  configured: { publicKey: Uint8Array },\n  resolved: { publicKey: Uint8Array } | undefined,\n  relationship: KeyRelationship,\n): Promise<void> {\n  if (!resolved) {\n    throw new Error(\n      `Your on-chain DID is broken: the resolved key for ${relationship} is undefined`,\n    );\n  }\n\n  const derivedHex = Utils.Crypto.u8aToHex(configured.publicKey);\n  const resolvedHex = Utils.Crypto.u8aToHex(resolved.publicKey);\n\n  if (derivedHex !== resolvedHex) {\n    throw new Error(\n      `Your on-chain DID is broken: the configured key for ${relationship} does not match resolved one`,\n    );\n  }\n}\n\nasync function compareAllKeys(fullDid: DidDocument): Promise<void> {\n  const keypairs = await keypairsPromise;\n\n  await compareKeys(\n    keypairs.authentication,\n    fullDid.authentication[0],\n    'authentication',\n  );\n  await compareKeys(\n    keypairs.assertionMethod,\n    fullDid.assertionMethod?.[0],\n    'assertionMethod',\n  );\n  await compareKeys(\n    keypairs.keyAgreement,\n    fullDid.keyAgreement?.[0],\n    'keyAgreement',\n  );\n}\n\nexport const didDocumentPromise = (async () => {\n  await initKilt();\n\n  const { did } = configuration;\n  if (!did) {\n    throw new Error('DID not configured, have you run createDID script?');\n  }\n\n  const resolved = await Did.resolve(did);\n  if (!resolved || !resolved.document) {\n    throw new Error(\n      `Could not resolve the configured DID ${did}, have you run createDID script?`,\n    );\n  }\n\n  const { document } = resolved;\n  await compareAllKeys(document);\n\n  const authenticationKey = document.authentication?.[0];\n  if (!authenticationKey) {\n    throw new Error('Impossible: authentication key not found');\n  }\n\n  const assertionMethodKey = document.assertionMethod?.[0];\n  if (!assertionMethodKey) {\n    throw new Error('Impossible: assertion method key not found');\n  }\n\n  const keyAgreementKey = document.keyAgreement?.[0];\n  if (!keyAgreementKey) {\n    throw new Error('Impossible: key agreement key not found');\n  }\n\n  return {\n    did,\n    didDocument: document,\n    authenticationKey,\n    assertionMethodKey,\n    keyAgreementKey,\n  };\n})();\n","import { pino } from 'pino';\n\nexport const logger = pino({\n  level: 'trace',\n  transport: {\n    target: 'pino-pretty',\n  },\n});\n","import basicAuth from 'express-basic-auth';\nimport { configuration } from './configuration';\n\nconst { adminUsername, adminPassword } = configuration;\n\nexport const auth = basicAuth({\n  users: { [adminUsername]: adminPassword },\n  challenge: true,\n});\n","export const paths = {\n  session: '/api/session',\n  terms: '/api/terms',\n  requestAttestation: '/api/request-attestation',\n  pay: '/api/pay',\n\n  // admin\n  credentials: {\n    list: '/api/credentials',\n    item: '/api/credentials/:id',\n    attest: '/api/credentials/:id/attest',\n    revoke: '/api/credentials/:id/revoke',\n  },\n};\n","import { randomUUID } from 'node:crypto';\n\nimport { IAttestation, ICredential } from '@kiltprotocol/sdk-js';\n\nexport class NotFoundError extends Error {}\n\nexport interface Credential {\n  claim: ICredential;\n  attestation?: IAttestation;\n}\n\n// Maps are used for example purposes. A real database should be used in production.\nconst credentials: Map<string, Credential> = new Map();\n\nexport function addClaim(claim: ICredential) {\n  const id = randomUUID();\n  credentials.set(id, { claim });\n}\n\nexport function listCredentials() {\n  return Object.fromEntries(credentials.entries());\n}\n\nexport function getCredential(id: string) {\n  const credential = credentials.get(id);\n  if (!credential) {\n    throw new NotFoundError('Credential not found');\n  }\n  return credential;\n}\n\nexport function deleteCredential(id: string) {\n  const deleted = credentials.delete(id);\n  if (!deleted) {\n    throw new NotFoundError('Credential not found');\n  }\n}\n\nexport function addAttestation(id: string, attestation: IAttestation) {\n  const credential = getCredential(id);\n  credentials.set(id, { ...credential, attestation });\n  return getCredential(id);\n}\n","import {\n  DecryptCallback,\n  DidResourceUri,\n  EncryptCallback,\n  SignRequestData,\n  Utils,\n} from '@kiltprotocol/sdk-js';\n\nimport { keypairsPromise } from './keypairs';\nimport { didDocumentPromise } from './didDocument';\n\nexport async function sign({ data, keyRelationship }: SignRequestData) {\n  if (keyRelationship === 'capabilityDelegation') {\n    throw new Error('Delegation not supported');\n  }\n  const { authentication, assertionMethod } = await keypairsPromise;\n  const { did, authenticationKey, assertionMethodKey } =\n    await didDocumentPromise;\n\n  const [keypair, publicKey] =\n    keyRelationship === 'authentication'\n      ? [authentication, authenticationKey]\n      : [assertionMethod, assertionMethodKey];\n\n  const keyUri: DidResourceUri = `${did}${publicKey.id}`;\n\n  return {\n    signature: keypair.sign(data, { withType: false }),\n    keyType: keypair.type,\n    keyUri,\n  };\n}\n\nexport async function signWithAssertionMethod({ data }: { data: Uint8Array }) {\n  const { assertionMethod } = await keypairsPromise;\n\n  const { did, assertionMethodKey } = await didDocumentPromise;\n  const keyUri: DidResourceUri = `${did}${assertionMethodKey.id}`;\n\n  return {\n    signature: assertionMethod.sign(data, { withType: false }),\n    keyType: assertionMethod.type,\n    keyUri,\n  };\n}\n\nexport async function encrypt({\n  data,\n  peerPublicKey,\n}: Parameters<EncryptCallback>[0]) {\n  const { keyAgreement } = await keypairsPromise;\n\n  const { did, keyAgreementKey } = await didDocumentPromise;\n  const keyUri: DidResourceUri = `${did}${keyAgreementKey.id}`;\n\n  const { box, nonce } = Utils.Crypto.encryptAsymmetric(\n    data,\n    peerPublicKey,\n    keyAgreement.secretKey,\n  );\n\n  return {\n    data: box,\n    nonce,\n    keyUri,\n  };\n}\n\nexport async function decrypt({\n  data: box,\n  nonce,\n  peerPublicKey,\n}: Parameters<DecryptCallback>[0]) {\n  const { keyAgreement } = await keypairsPromise;\n\n  const data = Utils.Crypto.decryptAsymmetric(\n    { box, nonce },\n    peerPublicKey,\n    keyAgreement.secretKey,\n  );\n  if (!data) {\n    throw new Error('Failed to decrypt with given key');\n  }\n\n  return {\n    data,\n  };\n}\n","import {\n  Attestation,\n  Blockchain,\n  ConfigService,\n  Did,\n  IAttestation,\n  ICredential,\n} from '@kiltprotocol/sdk-js';\nimport { configuration } from './configuration';\nimport { sign } from './cryptoCallbacks';\nimport { keypairsPromise } from './keypairs';\n\nexport async function attest(credential: ICredential): Promise<IAttestation> {\n  const api = ConfigService.get('api');\n\n  const attestation = Attestation.fromCredentialAndDid(\n    credential,\n    configuration.did,\n  );\n\n  const { claimHash, cTypeHash } = attestation;\n\n  const { payer } = await keypairsPromise;\n\n  const tx = api.tx.attestation.add(claimHash, cTypeHash, null);\n  const authorized = await Did.authorizeTx(\n    configuration.did,\n    tx,\n    sign,\n    payer.address,\n  );\n\n  await Blockchain.signAndSubmitTx(authorized, payer);\n\n  return attestation;\n}\n","import {\n  Attestation,\n  Blockchain,\n  ConfigService,\n  Did,\n  ICredential,\n} from '@kiltprotocol/sdk-js';\nimport { configuration } from './configuration';\nimport { sign } from './cryptoCallbacks';\nimport { keypairsPromise } from './keypairs';\n\nexport async function revoke(credential: ICredential) {\n  const api = ConfigService.get('api');\n  const { rootHash } = credential;\n\n  const tx = api.tx.attestation.revoke(rootHash, null);\n\n  const { payer } = await keypairsPromise;\n\n  const authorized = await Did.authorizeTx(\n    configuration.did,\n    tx,\n    sign,\n    payer.address,\n  );\n\n  await Blockchain.signAndSubmitTx(authorized, payer);\n\n  const attestation = await api.query.attestation.attestations(rootHash);\n\n  return Attestation.fromChain(attestation, rootHash);\n}\n","import { Response, Router } from 'express';\nimport { paths } from '../paths';\nimport {\n  NotFoundError,\n  deleteCredential,\n  getCredential,\n  listCredentials,\n  addAttestation,\n} from '../../utilities/credentialStorage';\nimport { StatusCodes } from 'http-status-codes';\nimport { logger } from '../../utilities/logger';\nimport { attest } from '../../utilities/attest';\nimport { revoke } from '../../utilities/revoke';\n\nfunction sendErrorResponse(error: unknown, response: Response) {\n  logger.error(error);\n  if (error instanceof NotFoundError) {\n    response.status(StatusCodes.NOT_FOUND).send(error);\n  } else {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const credentials = Router();\n\ncredentials.get(paths.credentials.list, async (request, response) => {\n  logger.debug('Getting list of credentials');\n  response.send(listCredentials());\n});\n\ncredentials.get(paths.credentials.item, async (request, response) => {\n  try {\n    const { id } = request.params;\n    logger.debug(`Getting credential`);\n    response.send(getCredential(id));\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n\ncredentials.delete(paths.credentials.item, async (request, response) => {\n  try {\n    const { id } = request.params;\n    logger.debug('Deleting credential');\n\n    deleteCredential(id);\n\n    response.sendStatus(StatusCodes.OK);\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n\ncredentials.post(paths.credentials.attest, async (request, response) => {\n  try {\n    const { id } = request.params;\n\n    logger.debug(`Getting credential`);\n    const { claim } = getCredential(id);\n\n    logger.debug('Attesting credential');\n    const attestation = await attest(claim);\n\n    logger.debug('Credential attested, updating database');\n    const attestedCredential = addAttestation(id, attestation);\n\n    response.send(attestedCredential);\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n\ncredentials.post(paths.credentials.revoke, async (request, response) => {\n  try {\n    const { id } = request.params;\n\n    logger.debug('Getting credential');\n    const { claim } = getCredential(id);\n\n    logger.debug('Revoking credential');\n    const attestation = await revoke(claim);\n\n    logger.debug('Credential revoked, updating database');\n    const revokedCredential = addAttestation(id, attestation);\n\n    response.send(revokedCredential);\n  } catch (error) {\n    sendErrorResponse(error, response);\n  }\n});\n","import express, { Router } from 'express';\nimport { configuration } from '../utilities/configuration';\n\nimport { credentials } from '../endpoints/admin/credentials';\n\nexport const adminRouter = Router();\n\nadminRouter.use(credentials);\n\nadminRouter.use(\n  // eslint-disable-next-line import/no-named-as-default-member\n  express.static(`${configuration.distFolder}/admin`, {\n    dotfiles: 'allow',\n    setHeaders(res) {\n      res.set('Access-Control-Allow-Origin', '*');\n    },\n  }),\n);\n\nadminRouter.get('*', (request, response) => {\n  response.sendFile(`${configuration.distFolder}/admin/index.html`);\n});\n","export const sessionHeader = 'x-session-id';\n","import { NextFunction, Request, Response } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport NodeCache from 'node-cache';\nimport { DidResourceUri, DidUri, ICredential } from '@kiltprotocol/sdk-js';\n\nimport { sessionHeader } from '../endpoints/user/sessionHeader';\n\nexport interface BasicSession {\n  sessionId: string;\n  did?: DidUri;\n  encryptionKeyUri?: DidResourceUri;\n  didChallenge?: string;\n  didConfirmed?: boolean;\n  credential?: ICredential;\n}\n\nexport type Session = BasicSession & {\n  did: DidUri;\n  encryptionKeyUri: DidResourceUri;\n};\n\nconst sessionStorage = new NodeCache({ stdTTL: 5 * 60 * 60, useClones: false });\n\nfunction getSessionById(sessionId: string): BasicSession {\n  const session = sessionStorage.get(sessionId);\n  if (!session) {\n    throw new Error(`Unknown or expired session ${sessionId}`);\n  }\n  return session as BasicSession;\n}\n\nfunction getBasicSession(request: Request): BasicSession {\n  const sessionId = request.get(sessionHeader);\n\n  if (!sessionId) {\n    throw new Error(`Required header ${sessionHeader} is missing`);\n  }\n\n  return getSessionById(sessionId);\n}\n\nfunction getSession(request: Request): Session {\n  const session = getBasicSession(request);\n\n  const { did, didConfirmed, encryptionKeyUri } = session;\n  if (!did || !didConfirmed || !encryptionKeyUri) {\n    throw new Error('Unconfirmed DID');\n  }\n\n  return { ...session, did, encryptionKeyUri };\n}\n\nexport function setSession(session: BasicSession): void {\n  sessionStorage.set(session.sessionId, session);\n}\n\nexport function basicSessionMiddleware(\n  request: Request,\n  response: Response,\n  next: NextFunction,\n): void {\n  try {\n    const session = getBasicSession(request);\n    (request as Request & { session: BasicSession }).session = session;\n    next();\n  } catch (error) {\n    response.status(StatusCodes.FORBIDDEN).send(error);\n  }\n}\n\nexport function sessionMiddleware(\n  request: Request,\n  response: Response,\n  next: NextFunction,\n): void {\n  try {\n    const session = getSession(request);\n    (request as Request & { session: Session }).session = session;\n    next();\n  } catch (error) {\n    response.status(StatusCodes.FORBIDDEN).send(error);\n  }\n}\n","import { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { logger } from '../../utilities/logger';\nimport { Session, sessionMiddleware } from '../../utilities/sessionStorage';\nimport { paths } from '../paths';\nimport { addClaim } from '../../utilities/credentialStorage';\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  // implement your payment logic here\n\n  try {\n    logger.debug('Mock processing payment');\n\n    const {\n      session: { credential },\n    } = request as Request & { session: Session };\n\n    if (!credential) {\n      throw new Error('Session credential not found');\n    }\n\n    addClaim(credential);\n\n    logger.debug('Payment received, sent credential to attester');\n    response.sendStatus(StatusCodes.NO_CONTENT);\n  } catch (error) {\n    logger.error(error);\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const pay = Router();\n\npay.post(paths.pay, sessionMiddleware, handler);\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const emailCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'Email',\n  properties: {\n    Email: {\n      type: 'string',\n    },\n  },\n  type: 'object',\n  $id: 'kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac',\n};\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nimport { emailCType } from '../cTypes/emailCType';\nimport { twitterCType } from '../cTypes/twitterCType';\nimport { idCType } from '../cTypes/idCType';\n\nexport const supportedCTypeKeys = ['email', 'twitter', 'id'] as const;\n\nexport type SupportedCType = (typeof supportedCTypeKeys)[number];\n\nexport const supportedCTypes: Record<SupportedCType, ICType> = {\n  email: emailCType,\n  twitter: twitterCType,\n  id: idCType,\n};\n\nexport const kiltCost: Record<SupportedCType, number> = {\n  id: 2,\n  email: 2,\n  twitter: 3,\n};\n\nexport function isSupportedCType(cType: string): cType is SupportedCType {\n  return supportedCTypeKeys.includes(cType as SupportedCType);\n}\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const twitterCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'Twitter',\n  properties: {\n    Twitter: {\n      type: 'string',\n    },\n  },\n  type: 'object',\n  $id: 'kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420',\n};\n","import type { ICType } from '@kiltprotocol/sdk-js';\n\nexport const idCType: ICType = {\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  properties: {\n    age: {\n      type: 'integer',\n    },\n    name: {\n      type: 'string',\n    },\n  },\n  title: 'INE ID',\n  type: 'object',\n  $id: 'kilt:ctype:0x3112e1e3fb387e5eb6c109aa45afc7ed9df01f1c90a976a8b00585abf817ca82',\n};\n","import { Credential, CType, Message, Quote } from '@kiltprotocol/sdk-js';\nimport { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { decrypt } from '../../utilities/cryptoCallbacks';\nimport { logger } from '../../utilities/logger';\nimport {\n  Session,\n  sessionMiddleware,\n  setSession,\n} from '../../utilities/sessionStorage';\nimport { supportedCTypes } from '../../utilities/supportedCTypes';\nimport { paths } from '../paths';\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  try {\n    logger.debug('Handling attestation request');\n\n    const message = await Message.decrypt(request.body, decrypt);\n    const messageBody = message.body;\n    logger.debug('Request attestation message decrypted');\n\n    Message.verifyMessageBody(messageBody);\n    const { type } = messageBody;\n\n    if (type === 'reject' || type === 'reject-terms') {\n      response.status(StatusCodes.CONFLICT).send('Message contains rejection');\n      return;\n    }\n\n    if (type !== 'request-attestation') {\n      throw new Error('Unexpected message type');\n    }\n\n    const { quote, credential } = messageBody.content;\n\n    if (quote) {\n      await Quote.verifyQuoteAgreement(quote);\n      logger.debug('Quote agreement verified');\n    }\n\n    const cTypes = Object.values(supportedCTypes);\n    const cTypeId = CType.hashToId(credential.claim.cTypeHash);\n    const ctype = cTypes.find(({ $id }) => $id === cTypeId);\n    if (!ctype) {\n      response.status(StatusCodes.FORBIDDEN).send('Unsupported CType');\n    }\n    logger.debug('CType supported');\n\n    await Credential.verifyWellFormed(credential, { ctype });\n    logger.debug('Credential data structure verified');\n\n    const { session } = request as Request & { session: Session };\n    setSession({ ...session, credential });\n\n    logger.debug('Request attestation complete');\n    response.sendStatus(StatusCodes.NO_CONTENT);\n  } catch (error) {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nexport const requestAttestation = Router();\n\nrequestAttestation.post(paths.requestAttestation, sessionMiddleware, handler);\n","import { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\n\nimport { Did, DidResourceUri, Utils } from '@kiltprotocol/sdk-js';\nimport { randomAsHex } from '@polkadot/util-crypto';\n\nimport { didDocumentPromise } from '../../utilities/didDocument';\nimport { decrypt } from '../../utilities/cryptoCallbacks';\nimport {\n  BasicSession,\n  basicSessionMiddleware,\n  setSession,\n} from '../../utilities/sessionStorage';\nimport { logger } from '../../utilities/logger';\n\nimport { paths } from '../paths';\n\nexport interface CheckSessionInput {\n  encryptionKeyUri: DidResourceUri;\n  encryptedChallenge: string;\n  nonce: string;\n}\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  try {\n    logger.debug('Session confirmation started');\n\n    const payload = request.body as CheckSessionInput;\n    const { encryptionKeyUri, encryptedChallenge, nonce } = payload;\n    const { session } = request as Request & { session: BasicSession };\n\n    const encryptionKey = await Did.resolveKey(encryptionKeyUri);\n\n    logger.debug('Session confirmation resolved DID encryption key');\n\n    const { keyAgreementKey, did } = await didDocumentPromise;\n\n    const { data } = await decrypt({\n      data: Utils.Crypto.coToUInt8(encryptedChallenge),\n      nonce: Utils.Crypto.coToUInt8(nonce),\n      keyUri: `${did}${keyAgreementKey.id}`,\n      peerPublicKey: encryptionKey.publicKey,\n    });\n    logger.debug('Session confirmation decrypted challenge');\n\n    const decryptedChallenge = Utils.Crypto.u8aToHex(data);\n    const originalChallenge = session.didChallenge;\n\n    if (decryptedChallenge !== originalChallenge) {\n      response\n        .status(StatusCodes.FORBIDDEN)\n        .send('Challenge signature mismatch');\n      return;\n    }\n\n    setSession({\n      ...session,\n      did: encryptionKey.controller,\n      encryptionKeyUri,\n      didConfirmed: true,\n    });\n\n    logger.debug('Challenge confirmation matches');\n    response.sendStatus(StatusCodes.NO_CONTENT);\n  } catch (error) {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\n\nfunction startSession() {\n  const sessionId = randomAsHex(24);\n  const challenge = randomAsHex(24);\n\n  setSession({ sessionId, didChallenge: challenge });\n\n  return {\n    challenge,\n    sessionId,\n  };\n}\n\nexport interface GetSessionOutput {\n  dAppEncryptionKeyUri: DidResourceUri;\n  sessionId: string;\n  challenge: string;\n}\n\nconst path = paths.session;\n\nexport const session = Router();\n\nsession.get(path, async (request, response) => {\n  const { did, keyAgreementKey } = await didDocumentPromise;\n  const dAppEncryptionKeyUri: DidResourceUri = `${did}${keyAgreementKey.id}`;\n  response.send({\n    dAppEncryptionKeyUri,\n    ...startSession(),\n  } as GetSessionOutput);\n});\n\nsession.post(path, basicSessionMiddleware, handler);\n","import type {\n  DidResourceUri,\n  IEncryptedMessage,\n  MessageBody,\n} from '@kiltprotocol/sdk-js';\nimport { Did, Message } from '@kiltprotocol/sdk-js';\n\nimport { encrypt } from './cryptoCallbacks';\nimport { configuration } from './configuration';\n\nexport async function encryptMessageBody(\n  encryptionKeyUri: DidResourceUri,\n  messageBody: MessageBody,\n): Promise<IEncryptedMessage> {\n  const { did } = Did.parse(encryptionKeyUri);\n\n  const message = Message.fromBody(messageBody, configuration.did, did);\n  return Message.encrypt(message, encrypt, encryptionKeyUri);\n}\n","import { Claim, IClaimContents, IQuote, Quote } from '@kiltprotocol/sdk-js';\nimport { Request, Response, Router } from 'express';\nimport { StatusCodes } from 'http-status-codes';\nimport { configuration } from '../../utilities/configuration';\nimport { sign } from '../../utilities/cryptoCallbacks';\nimport { encryptMessageBody } from '../../utilities/encryptMessage';\nimport { logger } from '../../utilities/logger';\nimport { Session, sessionMiddleware } from '../../utilities/sessionStorage';\nimport {\n  kiltCost,\n  SupportedCType,\n  supportedCTypes,\n} from '../../utilities/supportedCTypes';\nimport { paths } from '../paths';\n\nconst TTL = 5 * 60 * 60 * 1000;\nconst TERMS = 'https://example.com/terms-and-conditions';\n\ninterface Input {\n  type: SupportedCType;\n  claimContents: IClaimContents;\n}\n\nasync function handler(request: Request, response: Response): Promise<void> {\n  try {\n    logger.debug('Submit terms started');\n    const { session } = request as Request & { session: Session };\n    const { encryptionKeyUri } = session;\n\n    const { type, claimContents } = request.body as Input;\n\n    const claim = Claim.fromCTypeAndClaimContents(\n      supportedCTypes[type],\n      claimContents,\n      session.did,\n    );\n    logger.debug('Generated claim');\n\n    const quote: IQuote = {\n      attesterDid: configuration.did,\n      cTypeHash: claim.cTypeHash,\n      cost: { tax: { VAT: 0 }, net: kiltCost[type], gross: kiltCost[type] },\n      currency: 'KILT',\n      timeframe: new Date(Date.now() + TTL).toISOString(),\n      termsAndConditions: TERMS,\n    };\n\n    const signedQuote = await Quote.createAttesterSignedQuote(quote, sign);\n    logger.debug('Signed quote');\n\n    const output = await encryptMessageBody(encryptionKeyUri, {\n      content: {\n        claim,\n        legitimations: [],\n        quote: signedQuote,\n        cTypes: [supportedCTypes[type]],\n      },\n      type: 'submit-terms',\n    });\n    logger.debug('Submit terms complete');\n    response.send(output);\n  } catch (error) {\n    response.status(StatusCodes.INTERNAL_SERVER_ERROR).send(error);\n  }\n}\nexport const terms = Router();\n\nterms.post(paths.terms, sessionMiddleware, handler);\n","import express, { Router } from 'express';\nimport { pay } from '../endpoints/user/pay';\nimport { requestAttestation } from '../endpoints/user/requestAttestation';\nimport { session } from '../endpoints/user/session';\nimport { terms } from '../endpoints/user/terms';\nimport { configuration } from '../utilities/configuration';\n\nexport const userRouter = Router();\n\nuserRouter.use(session);\nuserRouter.use(terms);\nuserRouter.use(requestAttestation);\nuserRouter.use(pay);\n\nuserRouter.use(\n  // eslint-disable-next-line import/no-named-as-default-member\n  express.static(`${configuration.distFolder}/user`, {\n    dotfiles: 'allow',\n    setHeaders(res) {\n      res.set('Access-Control-Allow-Origin', '*');\n    },\n  }),\n);\n\nuserRouter.get('*', (request, response) => {\n  response.sendFile(`${configuration.distFolder}/user/index.html`);\n});\n","import express from 'express';\nimport bodyParser from 'body-parser';\n\nimport { didDocumentPromise } from './utilities/didDocument';\nimport { configuration } from './utilities/configuration';\nimport { logger } from './utilities/logger';\n\nimport { auth } from './utilities/auth';\nimport { adminRouter } from './routers/admin';\nimport { userRouter } from './routers/user';\n\nconst initApp = async () => {\n  await didDocumentPromise;\n  logger.info('Blockchain connection initialized');\n\n  const app = express();\n  app.use(bodyParser.json());\n\n  app.use('/admin', auth, adminRouter);\n  app.use('/', userRouter);\n\n  logger.info('Routes configured');\n\n  const host = '0.0.0.0';\n  const { port, baseUri } = configuration;\n  const started = app.listen(port, host, () =>\n    logger.info(`Listening on ${baseUri} (host: ${host}, port: ${port})`),\n  );\n\n  function stop() {\n    started.close();\n    process.exit(1);\n  }\n\n  process.on('unhandledRejection', stop);\n  process.on('uncaughtException', stop);\n\n  return app;\n};\n\nexport default initApp();\n"],"names":["$8li2e$config","$9a5082739595bce3$var$ConfigurationError","Error","constructor","message","super","$8li2e$pino","fatal","process","exit","env","$9a5082739595bce3$var$env","$9a5082739595bce3$var$baseUri","URL","$9a5082739595bce3$var$did","DID","$9a5082739595bce3$var$payerMnemonic","SECRET_PAYER_MNEMONIC","$9a5082739595bce3$var$authenticationMnemonic","SECRET_AUTHENTICATION_MNEMONIC","$9a5082739595bce3$var$assertionMethodMnemonic","SECRET_ASSERTION_METHOD_MNEMONIC","$9a5082739595bce3$var$keyAgreementMnemonic","SECRET_KEY_AGREEMENT_MNEMONIC","$9a5082739595bce3$var$blockchainEndpoint","BLOCKCHAIN_ENDPOINT","$9a5082739595bce3$var$adminUsername","ADMIN_USERNAME","$9a5082739595bce3$var$adminPassword","ADMIN_PASSWORD","$9a5082739595bce3$export$1670bf621bbc68f3","port","parseInt","PORT","distFolder","$8li2e$nodepath","join","$8li2e$cwd","$1749a0affe1e2fac$export$c289742f0747afa3","$8li2e$cryptoWaitReady","$8li2e$Utils","Crypto","makeKeypairFromUri","payerMnemonic","authenticationMnemonic","assertionMethodMnemonic","makeEncryptionKeypairFromSeed","mnemonicToMiniSecret","keyAgreementMnemonic","async","$d5e46af1030fd1ba$export$de423f52c8ea922","$8li2e$connect","blockchainEndpoint","$7e0b7c48c43039ee$var$compareKeys","configured","resolved","relationship","u8aToHex","publicKey","$7e0b7c48c43039ee$export$b8c12ba93511ecc0","did","$8li2e$Did","resolve","document","fullDid","keypairs","authentication","assertionMethod","keyAgreement","$7e0b7c48c43039ee$var$compareAllKeys","authenticationKey","assertionMethodKey","keyAgreementKey","didDocument","$15a6ac0367590b47$export$af88d00dbe7f521","level","transport","target","adminUsername","$b3dd54d8f90dbc1c$var$adminUsername","adminPassword","$b3dd54d8f90dbc1c$var$adminPassword","$b3dd54d8f90dbc1c$export$73693bad9f5880b0","$8li2e$expressbasicauth","users","challenge","$8b8135ac0a872448$export$595447059867920","session","terms","requestAttestation","pay","credentials","list","item","attest","revoke","$18cddce23ffb0b39$export$78c95b58762d2106","$18cddce23ffb0b39$var$credentials","Map","$18cddce23ffb0b39$export$fa223408cdeea5e5","claim","id","$8li2e$randomUUID","set","$18cddce23ffb0b39$export$298c59008c641b3e","credential","get","$18cddce23ffb0b39$export$663b6344735d0e78","delete","$18cddce23ffb0b39$export$a2813f6973ed113","attestation","$d04bc697e1db4f68$export$c5552dfdbc7cec71","data","keyRelationship","keypair","keyUri","signature","sign","withType","keyType","type","$d04bc697e1db4f68$export$5b0f6292f11d1d18","peerPublicKey","box","nonce","encryptAsymmetric","secretKey","$d04bc697e1db4f68$export$e85a0c9a1067c5d3","decryptAsymmetric","$ceb6527163e88ac4$export$994159fc52341244","api","$8li2e$ConfigService","$8li2e$Attestation","fromCredentialAndDid","claimHash","cTypeHash","payer","tx","add","authorized","authorizeTx","address","$8li2e$Blockchain","signAndSubmitTx","$7d9c09f48e3eea26$export$573f8dbbf6fbef75","rootHash","query","attestations","fromChain","$3a47d82b8ed8e023$var$sendErrorResponse","error","response","status","$8li2e$StatusCodes","NOT_FOUND","send","INTERNAL_SERVER_ERROR","$3a47d82b8ed8e023$export$78896651422bbf9e","$8li2e$Router","request","debug","Object","fromEntries","entries","params","sendStatus","OK","post","attestedCredential","revokedCredential","$8dcf704c811bb6ca$export$e73631d91f945400","use","$8li2e$express","static","dotfiles","setHeaders","res","sendFile","$cdebb7d266d5529a$var$sessionStorage","$8li2e$nodecache","stdTTL","useClones","$cdebb7d266d5529a$var$getBasicSession","sessionId","$cdebb7d266d5529a$var$getSessionById","$cdebb7d266d5529a$export$b94982631f8f9752","$cdebb7d266d5529a$export$f484ee341a6e9f8f","next","didConfirmed","encryptionKeyUri","$cdebb7d266d5529a$var$getSession","FORBIDDEN","$fa40543f7f9825c4$export$552d83b9289531dc","NO_CONTENT","$a0a27930e77ba031$export$fceeab0910ee116e","email","$schema","title","properties","Email","$id","twitter","Twitter","age","name","$a0a27930e77ba031$export$721e075907bcb4ad","$544f4c7c8812f4a4$export$ddf46a4b5b1c2865","$a2666dc51342e5ad$var$startSession","$8li2e$randomAsHex","didChallenge","messageBody","$8li2e$Message","decrypt","body","verifyMessageBody","CONFLICT","quote","content","$8li2e$Quote","verifyQuoteAgreement","cTypes","values","cTypeId","$8li2e$CType","hashToId","ctype","find","$8li2e$Credential","verifyWellFormed","$a2666dc51342e5ad$var$path","$a2666dc51342e5ad$export$55427e926be628d4","$d6888dba0634184a$export$5a3d317611b281f5","parse","fromBody","encrypt","dAppEncryptionKeyUri","payload","encryptedChallenge","encryptionKey","resolveKey","coToUInt8","decryptedChallenge","controller","$9956318176747e0e$export$8a21ba990ca4a7cb","claimContents","$8li2e$Claim","fromCTypeAndClaimContents","attesterDid","cost","tax","VAT","net","gross","currency","timeframe","Date","now","toISOString","termsAndConditions","signedQuote","createAttesterSignedQuote","output","legitimations","$9e4614c218229bd5$export$7bb46b7223ebd883","info","app","$8li2e$bodyparser","json","host","baseUri","started","listen","stop","close","on","$2dbda6e7de11ca31$var$initApp"],"version":3,"file":"server.js.map","sourceRoot":"../../"}