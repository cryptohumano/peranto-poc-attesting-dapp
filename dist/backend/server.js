import e,{Router as t}from"express";import n from"body-parser";import{Utils as o,Did as i,connect as s,ConfigService as a,Attestation as r,Blockchain as c,Message as d,Quote as p,CType as u,Credential as y,Claim as m}from"@kiltprotocol/sdk-js";import{cryptoWaitReady as l,randomAsHex as f}from"@polkadot/util-crypto";import{cwd as g}from"node:process";import h from"node:path";import{config as w}from"dotenv";import{pino as E}from"pino";import b from"pino-pretty";import R from"express-basic-auth";import{StatusCodes as C}from"http-status-codes";import{randomUUID as T}from"node:crypto";import N from"node-cache";import{getApps as A,initializeApp as I}from"firebase/app";import{getFirestore as k,updateDoc as M,doc as D}from"firebase/firestore";w();class O extends Error{constructor(e){super(e),E().fatal(e),process.exit(1)}}const{env:S}=process,v=S.URL;if(!v)throw new O("URL is not provided");const _=S.DID,K=S.SECRET_PAYER_MNEMONIC;if(!K)throw new O("SECRET_PAYER_MNEMONIC is not provided");const U=S.SECRET_AUTHENTICATION_MNEMONIC;if(!U)throw new O("SECRET_AUTHENTICATION_MNEMONIC is not provided");const x=S.SECRET_ASSERTION_METHOD_MNEMONIC;if(!x)throw new O("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const $=S.SECRET_KEY_AGREEMENT_MNEMONIC;if(!$)throw new O("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const F=S.BLOCKCHAIN_ENDPOINT;if(!F)throw new O("No blockchain endpoint provided");const H=S.ADMIN_USERNAME,j=S.ADMIN_PASSWORD;if(!H||!j)throw new O("Admin credentials missing");const L={port:parseInt(S.PORT)||3e3,blockchainEndpoint:F,baseUri:v,distFolder:h.join(g(),"dist","frontend"),did:_,payerMnemonic:K,authenticationMnemonic:U,assertionMethodMnemonic:x,keyAgreementMnemonic:$,adminUsername:H,adminPassword:j},q=(async()=>{await l();return{payer:o.Crypto.makeKeypairFromUri(L.payerMnemonic),authentication:o.Crypto.makeKeypairFromUri(L.authenticationMnemonic),assertionMethod:o.Crypto.makeKeypairFromUri(L.assertionMethodMnemonic),keyAgreement:o.Crypto.makeEncryptionKeypairFromSeed(o.Crypto.mnemonicToMiniSecret(L.keyAgreementMnemonic))}})();async function P(){await s(L.blockchainEndpoint)}async function B(e,t,n){if(!t)throw new Error(`Your on-chain DID is broken: the resolved key for ${n} is undefined`);if(o.Crypto.u8aToHex(e.publicKey)!==o.Crypto.u8aToHex(t.publicKey))throw new Error(`Your on-chain DID is broken: the configured key for ${n} does not match resolved one`)}const G=(async()=>{await P();const{did:e}=L;if(!e)throw new Error("DID not configured, have you run createDID script?");const t=await i.resolve(e);if(!t||!t.document)throw new Error(`Could not resolve the configured DID ${e}, have you run createDID script?`);const{document:n}=t;await async function(e){const t=await q;await B(t.authentication,e.authentication[0],"authentication"),await B(t.assertionMethod,e.assertionMethod?.[0],"assertionMethod"),await B(t.keyAgreement,e.keyAgreement?.[0],"keyAgreement")}(n);const o=n.authentication?.[0];if(!o)throw new Error("Impossible: authentication key not found");const s=n.assertionMethod?.[0];if(!s)throw new Error("Impossible: assertion method key not found");const a=n.keyAgreement?.[0];if(!a)throw new Error("Impossible: key agreement key not found");return{did:e,didDocument:n,authenticationKey:o,assertionMethodKey:s,keyAgreementKey:a}})(),z=b({levelFirst:!0,colorize:!0,ignore:"time,hostname,pid"}),V=E({level:"trace"},z),{adminUsername:Y,adminPassword:Q}=L,W=R({users:{[Y]:Q},challenge:!0}),J={session:"/api/session",terms:"/api/terms",requestAttestation:"/api/request-attestation",pay:"/api/pay",credentials:{list:"/api/credentials",item:"/api/credentials/:id",attest:"/api/credentials/:id/attest",revoke:"/api/credentials/:id/revoke"}};class X extends Error{}const Z=new Map;function ee(e){const t=T();Z.set(t,{claim:e})}function te(e){const t=Z.get(e);if(!t)throw new X("Credential not found");return t}function ne(e){if(!Z.delete(e))throw new X("Credential not found")}function oe(e,t){const n=te(e);return Z.set(e,{...n,attestation:t}),te(e)}async function ie({data:e,keyRelationship:t}){if("capabilityDelegation"===t)throw new Error("Delegation not supported");const{authentication:n,assertionMethod:o}=await q,{did:i,authenticationKey:s,assertionMethodKey:a}=await G,[r,c]="authentication"===t?[n,s]:[o,a],d=`${i}${c.id}`;return{signature:r.sign(e,{withType:!1}),keyType:r.type,keyUri:d}}async function se({data:e,peerPublicKey:t}){const{keyAgreement:n}=await q,{did:i,keyAgreementKey:s}=await G,a=`${i}${s.id}`,{box:r,nonce:c}=o.Crypto.encryptAsymmetric(e,t,n.secretKey);return{data:r,nonce:c,keyUri:a}}async function ae({data:e,nonce:t,peerPublicKey:n}){const{keyAgreement:i}=await q,s=o.Crypto.decryptAsymmetric({box:e,nonce:t},n,i.secretKey);if(!s)throw new Error("Failed to decrypt with given key");return{data:s}}async function re(e){const t=a.get("api"),n=r.fromCredentialAndDid(e,L.did),{claimHash:o,cTypeHash:s}=n,{payer:d}=await q,p=t.tx.attestation.add(o,s,null),u=await i.authorizeTx(L.did,p,ie,d.address);return await c.signAndSubmitTx(u,d),n}async function ce(e){const t=a.get("api"),{rootHash:n}=e,o=t.tx.attestation.revoke(n,null),{payer:s}=await q,d=await i.authorizeTx(L.did,o,ie,s.address);await c.signAndSubmitTx(d,s);const p=await t.query.attestation.attestations(n);return r.fromChain(p,n)}function de(e,t){V.error(e),e instanceof X?t.status(C.NOT_FOUND).send(e):t.status(C.INTERNAL_SERVER_ERROR).send(e)}const pe=t();pe.get(J.credentials.list,(async(e,t)=>{V.debug("Getting list of credentials"),t.send(Object.fromEntries(Z.entries()))})),pe.get(J.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;V.debug("Getting credential"),t.send(te(n))}catch(e){de(e,t)}})),pe.delete(J.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;V.debug("Deleting credential"),ne(n),t.sendStatus(C.OK)}catch(e){de(e,t)}})),pe.post(J.credentials.attest,(async(e,t)=>{try{const{id:n}=e.params;V.debug("Getting credential");const{claim:o}=te(n);V.debug("Attesting credential");const i=await re(o);V.debug("Credential attested, updating database");const s=oe(n,i);t.send(s)}catch(e){de(e,t)}})),pe.post(J.credentials.revoke,(async(e,t)=>{try{const{id:n}=e.params;V.debug("Getting credential");const{claim:o}=te(n);V.debug("Revoking credential");const i=await ce(o);V.debug("Credential revoked, updating database");const s=oe(n,i);t.send(s)}catch(e){de(e,t)}}));const ue=t();ue.use(pe),ue.use(e.static(`${L.distFolder}/admin`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),ue.get("*",((e,t)=>{t.sendFile(`${L.distFolder}/admin/index.html`)}));const ye=new N({stdTTL:18e3,useClones:!1});function me(e){const t=e.get("x-session-id");if(!t)throw new Error("Required header x-session-id is missing");return function(e){const t=ye.get(e);if(!t)throw new Error(`Unknown or expired session ${e}`);return t}(t)}function le(e){ye.set(e.sessionId,e)}function fe(e,t,n){try{const t=function(e){const t=me(e),{did:n,didConfirmed:o,encryptionKeyUri:i}=t;if(!n||!o||!i)throw new Error("Unconfirmed DID");return{...t,did:n,encryptionKeyUri:i}}(e);e.session=t,n()}catch(e){t.status(C.FORBIDDEN).send(e)}}const ge=t();ge.post(J.pay,fe,(async function(e,t){try{V.debug("Mock processing payment");const{session:{credential:n}}=e;if(!n)throw new Error("Session credential not found");ee(n),V.debug("Payment received, sent credential to attester"),t.sendStatus(C.NO_CONTENT)}catch(e){V.error(e),t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const he={email:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Email",properties:{Email:{type:"string"}},type:"object",$id:"kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac"},twitter:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Twitter",properties:{Twitter:{type:"string"}},type:"object",$id:"kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420"},id:{$schema:"http://kilt-protocol.org/draft-01/ctype#",properties:{age:{type:"integer"},name:{type:"string"}},title:"INE ID",type:"object",$id:"kilt:ctype:0x3112e1e3fb387e5eb6c109aa45afc7ed9df01f1c90a976a8b00585abf817ca82"}},we={id:2,email:2,twitter:3};const Ee=t();function be(){const e=f(24),t=f(24);return le({sessionId:e,didChallenge:t}),{challenge:t,sessionId:e}}Ee.post(J.requestAttestation,fe,(async function(e,t){try{V.debug("Handling attestation request");const n=(await d.decrypt(e.body,ae)).body;V.debug("Request attestation message decrypted"),d.verifyMessageBody(n);const{type:o}=n;if("reject"===o||"reject-terms"===o)return void t.status(C.CONFLICT).send("Message contains rejection");if("request-attestation"!==o)throw new Error("Unexpected message type");const{quote:i,credential:s}=n.content;i&&(await p.verifyQuoteAgreement(i),V.debug("Quote agreement verified"));const a=Object.values(he),r=u.hashToId(s.claim.cTypeHash),c=a.find((({$id:e})=>e===r));c||t.status(C.FORBIDDEN).send("Unsupported CType"),V.debug("CType supported"),await y.verifyWellFormed(s,{ctype:c}),V.debug("Credential data structure verified");const{session:m}=e;le({...m,credential:s}),V.debug("Request attestation complete"),t.sendStatus(C.NO_CONTENT)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const Re=J.session,Ce=t();async function Te(e,t){const{did:n}=i.parse(e),o=d.fromBody(t,L.did,n);return d.encrypt(o,se,e)}Ce.get(Re,(async(e,t)=>{const{did:n,keyAgreementKey:o}=await G,i=`${n}${o.id}`;t.send({dAppEncryptionKeyUri:i,...be()})})),Ce.post(Re,(function(e,t,n){try{const t=me(e);e.session=t,n()}catch(e){t.status(C.FORBIDDEN).send(e)}}),(async function(e,t){try{V.debug("Session confirmation started");const n=e.body,{encryptionKeyUri:s,encryptedChallenge:a,nonce:r}=n,{session:c}=e,d=await i.resolveKey(s);V.debug("Session confirmation resolved DID encryption key");const{keyAgreementKey:p,did:u}=await G,{data:y}=await ae({data:o.Crypto.coToUInt8(a),nonce:o.Crypto.coToUInt8(r),keyUri:`${u}${p.id}`,peerPublicKey:d.publicKey});V.debug("Session confirmation decrypted challenge");const m=o.Crypto.u8aToHex(y);if(m!==c.didChallenge)return void t.status(C.FORBIDDEN).send("Challenge signature mismatch");le({...c,did:d.controller,encryptionKeyUri:s,didConfirmed:!0}),V.debug("Challenge confirmation matches"),t.sendStatus(C.NO_CONTENT)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const Ne=t();Ne.post(J.terms,fe,(async function(e,t){try{V.debug("Submit terms started");const{session:n}=e,{encryptionKeyUri:o}=n,{type:i,claimContents:s}=e.body,a=m.fromCTypeAndClaimContents(he[i],s,n.did);V.debug("Generated claim");const r={attesterDid:L.did,cTypeHash:a.cTypeHash,cost:{tax:{VAT:0},net:we[i],gross:we[i]},currency:"KILT",timeframe:new Date(Date.now()+18e6).toISOString(),termsAndConditions:"https://example.com/terms-and-conditions"},c=await p.createAttesterSignedQuote(r,ie);V.debug("Signed quote");const d=await Te(o,{content:{claim:a,legitimations:[],quote:c,cTypes:[he[i]]},type:"submit-terms"});V.debug("Submit terms complete"),t.send(d)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const Ae=A(),Ie=k(Ae.length>0?Ae[0]:I({apiKey:"AIzaSyAAwR5GvEUi3lLWy9bb1tz65jhvHI3vufc",authDomain:"peranto-test.firebaseapp.com",projectId:"peranto-test",storageBucket:"peranto-test.appspot.com",messagingSenderId:"777447831295",appId:"1:777447831295:web:6a987d7c8b307ecef43eca"}));const ke=t();ke.post("/api/metamap",(async function(e,t){try{const{flowId:n,eventName:o}=e.body,i=await M(D(Ie,"metamap",n),{[o]:e.body});t.json({docRef:i})}catch(e){V.error(e),t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const Me=t();Me.use(Ce),Me.use(Ne),Me.use(Ee),Me.use(ge),Me.use(ke),Me.use(e.static(`${L.distFolder}/user`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),Me.get("*",((e,t)=>{t.sendFile(`${L.distFolder}/user/index.html`)}));(async()=>{await G,V.info("Blockchain connection initialized");const t=e();t.use(n.json()),t.use("/admin",W,ue),t.use("/",Me),V.info("Routes configured");const o="0.0.0.0",{port:i,baseUri:s}=L,a=t.listen(i,o,(()=>V.info(`Listening on ${s} (host: 0.0.0.0, port: ${i})`)));function r(){a.close(),process.exit(1)}process.on("unhandledRejection",r),process.on("uncaughtException",r)})();
//# sourceMappingURL=server.js.map
