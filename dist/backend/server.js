import e,{Router as t}from"express";import n from"body-parser";import{Utils as o,Did as i,connect as s,ConfigService as a,Attestation as r,Blockchain as c,Message as d,Quote as p,CType as u,Credential as y,Claim as m}from"@kiltprotocol/sdk-js";import{cryptoWaitReady as l,randomAsHex as f}from"@polkadot/util-crypto";import{cwd as h}from"node:process";import g from"node:path";import{config as E}from"dotenv";import{pino as w}from"pino";import b from"pino-pretty";import R from"express-basic-auth";import{StatusCodes as C}from"http-status-codes";import{randomUUID as T}from"node:crypto";import N from"node-cache";import{initializeApp as A}from"firebase/app";E();class I extends Error{constructor(e){super(e),w().fatal(e),process.exit(1)}}const{env:k}=process,M=k.URL;if(!M)throw new I("URL is not provided");const D=k.DID,O=k.SECRET_PAYER_MNEMONIC;if(!O)throw new I("SECRET_PAYER_MNEMONIC is not provided");const S=k.SECRET_AUTHENTICATION_MNEMONIC;if(!S)throw new I("SECRET_AUTHENTICATION_MNEMONIC is not provided");const _=k.SECRET_ASSERTION_METHOD_MNEMONIC;if(!_)throw new I("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const v=k.SECRET_KEY_AGREEMENT_MNEMONIC;if(!v)throw new I("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const K=k.BLOCKCHAIN_ENDPOINT;if(!K)throw new I("No blockchain endpoint provided");const U=k.ADMIN_USERNAME,x=k.ADMIN_PASSWORD;if(!U||!x)throw new I("Admin credentials missing");const $={port:parseInt(k.PORT)||3e3,blockchainEndpoint:K,baseUri:M,distFolder:g.join(h(),"dist","frontend"),did:D,payerMnemonic:O,authenticationMnemonic:S,assertionMethodMnemonic:_,keyAgreementMnemonic:v,adminUsername:U,adminPassword:x},F=(async()=>{await l();return{payer:o.Crypto.makeKeypairFromUri($.payerMnemonic),authentication:o.Crypto.makeKeypairFromUri($.authenticationMnemonic),assertionMethod:o.Crypto.makeKeypairFromUri($.assertionMethodMnemonic),keyAgreement:o.Crypto.makeEncryptionKeypairFromSeed(o.Crypto.mnemonicToMiniSecret($.keyAgreementMnemonic))}})();async function H(){await s($.blockchainEndpoint)}async function j(e,t,n){if(!t)throw new Error(`Your on-chain DID is broken: the resolved key for ${n} is undefined`);if(o.Crypto.u8aToHex(e.publicKey)!==o.Crypto.u8aToHex(t.publicKey))throw new Error(`Your on-chain DID is broken: the configured key for ${n} does not match resolved one`)}const L=(async()=>{await H();const{did:e}=$;if(!e)throw new Error("DID not configured, have you run createDID script?");const t=await i.resolve(e);if(!t||!t.document)throw new Error(`Could not resolve the configured DID ${e}, have you run createDID script?`);const{document:n}=t;await async function(e){const t=await F;await j(t.authentication,e.authentication[0],"authentication"),await j(t.assertionMethod,e.assertionMethod?.[0],"assertionMethod"),await j(t.keyAgreement,e.keyAgreement?.[0],"keyAgreement")}(n);const o=n.authentication?.[0];if(!o)throw new Error("Impossible: authentication key not found");const s=n.assertionMethod?.[0];if(!s)throw new Error("Impossible: assertion method key not found");const a=n.keyAgreement?.[0];if(!a)throw new Error("Impossible: key agreement key not found");return{did:e,didDocument:n,authenticationKey:o,assertionMethodKey:s,keyAgreementKey:a}})(),q=b({levelFirst:!0,colorize:!0,ignore:"time,hostname,pid"}),P=w({level:"trace"},q),{adminUsername:B,adminPassword:G}=$,z=R({users:{[B]:G},challenge:!0}),V={session:"/api/session",terms:"/api/terms",requestAttestation:"/api/request-attestation",pay:"/api/pay",credentials:{list:"/api/credentials",item:"/api/credentials/:id",attest:"/api/credentials/:id/attest",revoke:"/api/credentials/:id/revoke"}};class Y extends Error{}const Q=new Map;function W(e){const t=T();Q.set(t,{claim:e})}function J(e){const t=Q.get(e);if(!t)throw new Y("Credential not found");return t}function X(e){if(!Q.delete(e))throw new Y("Credential not found")}function Z(e,t){const n=J(e);return Q.set(e,{...n,attestation:t}),J(e)}async function ee({data:e,keyRelationship:t}){if("capabilityDelegation"===t)throw new Error("Delegation not supported");const{authentication:n,assertionMethod:o}=await F,{did:i,authenticationKey:s,assertionMethodKey:a}=await L,[r,c]="authentication"===t?[n,s]:[o,a],d=`${i}${c.id}`;return{signature:r.sign(e,{withType:!1}),keyType:r.type,keyUri:d}}async function te({data:e,peerPublicKey:t}){const{keyAgreement:n}=await F,{did:i,keyAgreementKey:s}=await L,a=`${i}${s.id}`,{box:r,nonce:c}=o.Crypto.encryptAsymmetric(e,t,n.secretKey);return{data:r,nonce:c,keyUri:a}}async function ne({data:e,nonce:t,peerPublicKey:n}){const{keyAgreement:i}=await F,s=o.Crypto.decryptAsymmetric({box:e,nonce:t},n,i.secretKey);if(!s)throw new Error("Failed to decrypt with given key");return{data:s}}async function oe(e){const t=a.get("api"),n=r.fromCredentialAndDid(e,$.did),{claimHash:o,cTypeHash:s}=n,{payer:d}=await F,p=t.tx.attestation.add(o,s,null),u=await i.authorizeTx($.did,p,ee,d.address);return await c.signAndSubmitTx(u,d),n}async function ie(e){const t=a.get("api"),{rootHash:n}=e,o=t.tx.attestation.revoke(n,null),{payer:s}=await F,d=await i.authorizeTx($.did,o,ee,s.address);await c.signAndSubmitTx(d,s);const p=await t.query.attestation.attestations(n);return r.fromChain(p,n)}function se(e,t){P.error(e),e instanceof Y?t.status(C.NOT_FOUND).send(e):t.status(C.INTERNAL_SERVER_ERROR).send(e)}const ae=t();ae.get(V.credentials.list,(async(e,t)=>{P.debug("Getting list of credentials"),t.send(Object.fromEntries(Q.entries()))})),ae.get(V.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Getting credential"),t.send(J(n))}catch(e){se(e,t)}})),ae.delete(V.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Deleting credential"),X(n),t.sendStatus(C.OK)}catch(e){se(e,t)}})),ae.post(V.credentials.attest,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Getting credential");const{claim:o}=J(n);P.debug("Attesting credential");const i=await oe(o);P.debug("Credential attested, updating database");const s=Z(n,i);t.send(s)}catch(e){se(e,t)}})),ae.post(V.credentials.revoke,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Getting credential");const{claim:o}=J(n);P.debug("Revoking credential");const i=await ie(o);P.debug("Credential revoked, updating database");const s=Z(n,i);t.send(s)}catch(e){se(e,t)}}));const re=t();re.use(ae),re.use(e.static(`${$.distFolder}/admin`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),re.get("*",((e,t)=>{t.sendFile(`${$.distFolder}/admin/index.html`)}));const ce=new N({stdTTL:18e3,useClones:!1});function de(e){const t=e.get("x-session-id");if(!t)throw new Error("Required header x-session-id is missing");return function(e){const t=ce.get(e);if(!t)throw new Error(`Unknown or expired session ${e}`);return t}(t)}function pe(e){ce.set(e.sessionId,e)}function ue(e,t,n){try{const t=function(e){const t=de(e),{did:n,didConfirmed:o,encryptionKeyUri:i}=t;if(!n||!o||!i)throw new Error("Unconfirmed DID");return{...t,did:n,encryptionKeyUri:i}}(e);e.session=t,n()}catch(e){t.status(C.FORBIDDEN).send(e)}}const ye=t();ye.post(V.pay,ue,(async function(e,t){try{P.debug("Mock processing payment");const{session:{credential:n}}=e;if(!n)throw new Error("Session credential not found");W(n),P.debug("Payment received, sent credential to attester"),t.sendStatus(C.NO_CONTENT)}catch(e){P.error(e),t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const me={email:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Email",properties:{Email:{type:"string"}},type:"object",$id:"kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac"},twitter:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Twitter",properties:{Twitter:{type:"string"}},type:"object",$id:"kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420"},id:{$schema:"http://kilt-protocol.org/draft-01/ctype#",properties:{age:{type:"integer"},name:{type:"string"}},title:"INE ID",type:"object",$id:"kilt:ctype:0x3112e1e3fb387e5eb6c109aa45afc7ed9df01f1c90a976a8b00585abf817ca82"}},le={id:2,email:2,twitter:3};const fe=t();function he(){const e=f(24),t=f(24);return pe({sessionId:e,didChallenge:t}),{challenge:t,sessionId:e}}fe.post(V.requestAttestation,ue,(async function(e,t){try{P.debug("Handling attestation request");const n=(await d.decrypt(e.body,ne)).body;P.debug("Request attestation message decrypted"),d.verifyMessageBody(n);const{type:o}=n;if("reject"===o||"reject-terms"===o)return void t.status(C.CONFLICT).send("Message contains rejection");if("request-attestation"!==o)throw new Error("Unexpected message type");const{quote:i,credential:s}=n.content;i&&(await p.verifyQuoteAgreement(i),P.debug("Quote agreement verified"));const a=Object.values(me),r=u.hashToId(s.claim.cTypeHash),c=a.find((({$id:e})=>e===r));c||t.status(C.FORBIDDEN).send("Unsupported CType"),P.debug("CType supported"),await y.verifyWellFormed(s,{ctype:c}),P.debug("Credential data structure verified");const{session:m}=e;pe({...m,credential:s}),P.debug("Request attestation complete"),t.sendStatus(C.NO_CONTENT)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const ge=V.session,Ee=t();async function we(e,t){const{did:n}=i.parse(e),o=d.fromBody(t,$.did,n);return d.encrypt(o,te,e)}Ee.get(ge,(async(e,t)=>{const{did:n,keyAgreementKey:o}=await L,i=`${n}${o.id}`;t.send({dAppEncryptionKeyUri:i,...he()})})),Ee.post(ge,(function(e,t,n){try{const t=de(e);e.session=t,n()}catch(e){t.status(C.FORBIDDEN).send(e)}}),(async function(e,t){try{P.debug("Session confirmation started");const n=e.body,{encryptionKeyUri:s,encryptedChallenge:a,nonce:r}=n,{session:c}=e,d=await i.resolveKey(s);P.debug("Session confirmation resolved DID encryption key");const{keyAgreementKey:p,did:u}=await L,{data:y}=await ne({data:o.Crypto.coToUInt8(a),nonce:o.Crypto.coToUInt8(r),keyUri:`${u}${p.id}`,peerPublicKey:d.publicKey});P.debug("Session confirmation decrypted challenge");const m=o.Crypto.u8aToHex(y);if(m!==c.didChallenge)return void t.status(C.FORBIDDEN).send("Challenge signature mismatch");pe({...c,did:d.controller,encryptionKeyUri:s,didConfirmed:!0}),P.debug("Challenge confirmation matches"),t.sendStatus(C.NO_CONTENT)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const be=t();be.post(V.terms,ue,(async function(e,t){try{P.debug("Submit terms started");const{session:n}=e,{encryptionKeyUri:o}=n,{type:i,claimContents:s}=e.body,a=m.fromCTypeAndClaimContents(me[i],s,n.did);P.debug("Generated claim");const r={attesterDid:$.did,cTypeHash:a.cTypeHash,cost:{tax:{VAT:0},net:le[i],gross:le[i]},currency:"KILT",timeframe:new Date(Date.now()+18e6).toISOString(),termsAndConditions:"https://example.com/terms-and-conditions"},c=await p.createAttesterSignedQuote(r,ee);P.debug("Signed quote");const d=await we(o,{content:{claim:a,legitimations:[],quote:c,cTypes:[me[i]]},type:"submit-terms"});P.debug("Submit terms complete"),t.send(d)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));A({apiKey:"AIzaSyAAwR5GvEUi3lLWy9bb1tz65jhvHI3vufc",authDomain:"peranto-test.firebaseapp.com",projectId:"peranto-test",storageBucket:"peranto-test.appspot.com",messagingSenderId:"777447831295",appId:"1:777447831295:web:6a987d7c8b307ecef43eca"});const Re=t();Re.get("/api/metamap",(async function(e,t){try{t.json({true:!0})}catch(e){P.error(e),t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const Ce=t();Ce.use(Ee),Ce.use(be),Ce.use(fe),Ce.use(ye),Ce.use(Re),Ce.use(e.static(`${$.distFolder}/user`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),Ce.get("*",((e,t)=>{t.sendFile(`${$.distFolder}/user/index.html`)}));(async()=>{await L,P.info("Blockchain connection initialized");const t=e();t.use(n.json()),t.use("/admin",z,re),t.use("/",Ce),P.info("Routes configured");const o="0.0.0.0",{port:i,baseUri:s}=$,a=t.listen(i,o,(()=>P.info(`Listening on ${s} (host: 0.0.0.0, port: ${i})`)));function r(){a.close(),process.exit(1)}process.on("unhandledRejection",r),process.on("uncaughtException",r)})();
//# sourceMappingURL=server.js.map
