import e,{Router as t}from"express";import n from"body-parser";import{Utils as o,Did as i,connect as s,ConfigService as r,Attestation as a,Blockchain as c,Message as d,Quote as u,CType as p,Credential as y,Claim as l}from"@kiltprotocol/sdk-js";import{cryptoWaitReady as m,randomAsHex as f}from"@polkadot/util-crypto";import{cwd as h}from"node:process";import g from"node:path";import{config as w}from"dotenv";import{pino as E}from"pino";import b from"pino-pretty";import C from"express-basic-auth";import{StatusCodes as T}from"http-status-codes";import{randomUUID as R}from"node:crypto";import N from"node-cache";w();class k extends Error{constructor(e){super(e),E().fatal(e),process.exit(1)}}const{env:A}=process,I=A.URL;if(!I)throw new k("URL is not provided");const M=A.DID,D=A.SECRET_PAYER_MNEMONIC;if(!D)throw new k("SECRET_PAYER_MNEMONIC is not provided");const O=A.SECRET_AUTHENTICATION_MNEMONIC;if(!O)throw new k("SECRET_AUTHENTICATION_MNEMONIC is not provided");const S=A.SECRET_ASSERTION_METHOD_MNEMONIC;if(!S)throw new k("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const _=A.SECRET_KEY_AGREEMENT_MNEMONIC;if(!_)throw new k("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const v=A.BLOCKCHAIN_ENDPOINT;if(!v)throw new k("No blockchain endpoint provided");const K=A.ADMIN_USERNAME,U=A.ADMIN_PASSWORD;if(!K||!U)throw new k("Admin credentials missing");const x={port:parseInt(A.PORT)||3e3,blockchainEndpoint:v,baseUri:I,distFolder:g.join(h(),"dist","frontend"),did:M,payerMnemonic:D,authenticationMnemonic:O,assertionMethodMnemonic:S,keyAgreementMnemonic:_,adminUsername:K,adminPassword:U},$=(async()=>{await m();return{payer:o.Crypto.makeKeypairFromUri(x.payerMnemonic),authentication:o.Crypto.makeKeypairFromUri(x.authenticationMnemonic),assertionMethod:o.Crypto.makeKeypairFromUri(x.assertionMethodMnemonic),keyAgreement:o.Crypto.makeEncryptionKeypairFromSeed(o.Crypto.mnemonicToMiniSecret(x.keyAgreementMnemonic))}})();async function F(){await s(x.blockchainEndpoint)}async function H(e,t,n){if(!t)throw new Error(`Your on-chain DID is broken: the resolved key for ${n} is undefined`);if(o.Crypto.u8aToHex(e.publicKey)!==o.Crypto.u8aToHex(t.publicKey))throw new Error(`Your on-chain DID is broken: the configured key for ${n} does not match resolved one`)}const j=(async()=>{await F();const{did:e}=x;if(!e)throw new Error("DID not configured, have you run createDID script?");const t=await i.resolve(e);if(!t||!t.document)throw new Error(`Could not resolve the configured DID ${e}, have you run createDID script?`);const{document:n}=t;await async function(e){const t=await $;await H(t.authentication,e.authentication[0],"authentication"),await H(t.assertionMethod,e.assertionMethod?.[0],"assertionMethod"),await H(t.keyAgreement,e.keyAgreement?.[0],"keyAgreement")}(n);const o=n.authentication?.[0];if(!o)throw new Error("Impossible: authentication key not found");const s=n.assertionMethod?.[0];if(!s)throw new Error("Impossible: assertion method key not found");const r=n.keyAgreement?.[0];if(!r)throw new Error("Impossible: key agreement key not found");return{did:e,didDocument:n,authenticationKey:o,assertionMethodKey:s,keyAgreementKey:r}})(),q=b({levelFirst:!0,colorize:!0,ignore:"time,hostname,pid"}),L=E({level:"trace"},q),{adminUsername:P,adminPassword:B}=x,G=C({users:{[P]:B},challenge:!0}),V={session:"/api/session",terms:"/api/terms",requestAttestation:"/api/request-attestation",pay:"/api/pay",credentials:{list:"/api/credentials",item:"/api/credentials/:id",attest:"/api/credentials/:id/attest",revoke:"/api/credentials/:id/revoke"}};class Y extends Error{}const z=new Map;function Q(e){const t=R();z.set(t,{claim:e})}function W(e){const t=z.get(e);if(!t)throw new Y("Credential not found");return t}function J(e){if(!z.delete(e))throw new Y("Credential not found")}function X(e,t){const n=W(e);return z.set(e,{...n,attestation:t}),W(e)}async function Z({data:e,keyRelationship:t}){if("capabilityDelegation"===t)throw new Error("Delegation not supported");const{authentication:n,assertionMethod:o}=await $,{did:i,authenticationKey:s,assertionMethodKey:r}=await j,[a,c]="authentication"===t?[n,s]:[o,r],d=`${i}${c.id}`;return{signature:a.sign(e,{withType:!1}),keyType:a.type,keyUri:d}}async function ee({data:e,peerPublicKey:t}){const{keyAgreement:n}=await $,{did:i,keyAgreementKey:s}=await j,r=`${i}${s.id}`,{box:a,nonce:c}=o.Crypto.encryptAsymmetric(e,t,n.secretKey);return{data:a,nonce:c,keyUri:r}}async function te({data:e,nonce:t,peerPublicKey:n}){const{keyAgreement:i}=await $,s=o.Crypto.decryptAsymmetric({box:e,nonce:t},n,i.secretKey);if(!s)throw new Error("Failed to decrypt with given key");return{data:s}}async function ne(e){const t=r.get("api"),n=a.fromCredentialAndDid(e,x.did),{claimHash:o,cTypeHash:s}=n,{payer:d}=await $,u=t.tx.attestation.add(o,s,null),p=await i.authorizeTx(x.did,u,Z,d.address);return await c.signAndSubmitTx(p,d),n}async function oe(e){const t=r.get("api"),{rootHash:n}=e,o=t.tx.attestation.revoke(n,null),{payer:s}=await $,d=await i.authorizeTx(x.did,o,Z,s.address);await c.signAndSubmitTx(d,s);const u=await t.query.attestation.attestations(n);return a.fromChain(u,n)}function ie(e,t){L.error(e),e instanceof Y?t.status(T.NOT_FOUND).send(e):t.status(T.INTERNAL_SERVER_ERROR).send(e)}const se=t();se.get(V.credentials.list,(async(e,t)=>{L.debug("Getting list of credentials"),t.send(Object.fromEntries(z.entries()))})),se.get(V.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;L.debug("Getting credential"),t.send(W(n))}catch(e){ie(e,t)}})),se.delete(V.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;L.debug("Deleting credential"),J(n),t.sendStatus(T.OK)}catch(e){ie(e,t)}})),se.post(V.credentials.attest,(async(e,t)=>{try{const{id:n}=e.params;L.debug("Getting credential");const{claim:o}=W(n);L.debug("Attesting credential");const i=await ne(o);L.debug("Credential attested, updating database");const s=X(n,i);t.send(s)}catch(e){ie(e,t)}})),se.post(V.credentials.revoke,(async(e,t)=>{try{const{id:n}=e.params;L.debug("Getting credential");const{claim:o}=W(n);L.debug("Revoking credential");const i=await oe(o);L.debug("Credential revoked, updating database");const s=X(n,i);t.send(s)}catch(e){ie(e,t)}}));const re=t();re.use(se),re.use(e.static(`${x.distFolder}/admin`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),re.get("*",((e,t)=>{t.sendFile(`${x.distFolder}/admin/index.html`)}));const ae=new N({stdTTL:18e3,useClones:!1});function ce(e){const t=e.get("x-session-id");if(!t)throw new Error("Required header x-session-id is missing");return function(e){const t=ae.get(e);if(!t)throw new Error(`Unknown or expired session ${e}`);return t}(t)}function de(e){ae.set(e.sessionId,e)}function ue(e,t,n){try{const t=function(e){const t=ce(e),{did:n,didConfirmed:o,encryptionKeyUri:i}=t;if(!n||!o||!i)throw new Error("Unconfirmed DID");return{...t,did:n,encryptionKeyUri:i}}(e);e.session=t,n()}catch(e){t.status(T.FORBIDDEN).send(e)}}const pe=t();pe.post(V.pay,ue,(async function(e,t){try{L.debug("Mock processing payment");const{session:{credential:n}}=e;if(!n)throw new Error("Session credential not found");Q(n),L.debug("Payment received, sent credential to attester"),t.sendStatus(T.NO_CONTENT)}catch(e){L.error(e),t.status(T.INTERNAL_SERVER_ERROR).send(e)}}));const ye={email:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Email",properties:{Email:{type:"string"}},type:"object",$id:"kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac"},twitter:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Twitter",properties:{Twitter:{type:"string"}},type:"object",$id:"kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420"},id:{$schema:"http://kilt-protocol.org/draft-01/ctype#",properties:{age:{type:"integer"},name:{type:"string"}},title:"INE ID",type:"object",$id:"kilt:ctype:0x3112e1e3fb387e5eb6c109aa45afc7ed9df01f1c90a976a8b00585abf817ca82"}},le={id:2,email:2,twitter:3};const me=t();function fe(){const e=f(24),t=f(24);return de({sessionId:e,didChallenge:t}),{challenge:t,sessionId:e}}me.post(V.requestAttestation,ue,(async function(e,t){try{L.debug("Handling attestation request");const n=(await d.decrypt(e.body,te)).body;L.debug("Request attestation message decrypted"),d.verifyMessageBody(n);const{type:o}=n;if("reject"===o||"reject-terms"===o)return void t.status(T.CONFLICT).send("Message contains rejection");if("request-attestation"!==o)throw new Error("Unexpected message type");const{quote:i,credential:s}=n.content;i&&(await u.verifyQuoteAgreement(i),L.debug("Quote agreement verified"));const r=Object.values(ye),a=p.hashToId(s.claim.cTypeHash),c=r.find((({$id:e})=>e===a));c||t.status(T.FORBIDDEN).send("Unsupported CType"),L.debug("CType supported"),await y.verifyWellFormed(s,{ctype:c}),L.debug("Credential data structure verified");const{session:l}=e;de({...l,credential:s}),L.debug("Request attestation complete"),t.sendStatus(T.NO_CONTENT)}catch(e){t.status(T.INTERNAL_SERVER_ERROR).send(e)}}));const he=V.session,ge=t();async function we(e,t){const{did:n}=i.parse(e),o=d.fromBody(t,x.did,n);return d.encrypt(o,ee,e)}ge.get(he,(async(e,t)=>{const{did:n,keyAgreementKey:o}=await j,i=`${n}${o.id}`;t.send({dAppEncryptionKeyUri:i,...fe()})})),ge.post(he,(function(e,t,n){try{const t=ce(e);e.session=t,n()}catch(e){t.status(T.FORBIDDEN).send(e)}}),(async function(e,t){try{L.debug("Session confirmation started");const n=e.body,{encryptionKeyUri:s,encryptedChallenge:r,nonce:a}=n,{session:c}=e,d=await i.resolveKey(s);L.debug("Session confirmation resolved DID encryption key");const{keyAgreementKey:u,did:p}=await j,{data:y}=await te({data:o.Crypto.coToUInt8(r),nonce:o.Crypto.coToUInt8(a),keyUri:`${p}${u.id}`,peerPublicKey:d.publicKey});L.debug("Session confirmation decrypted challenge");const l=o.Crypto.u8aToHex(y);if(l!==c.didChallenge)return void t.status(T.FORBIDDEN).send("Challenge signature mismatch");de({...c,did:d.controller,encryptionKeyUri:s,didConfirmed:!0}),L.debug("Challenge confirmation matches"),t.sendStatus(T.NO_CONTENT)}catch(e){t.status(T.INTERNAL_SERVER_ERROR).send(e)}}));const Ee=t();Ee.post(V.terms,ue,(async function(e,t){try{L.debug("Submit terms started");const{session:n}=e,{encryptionKeyUri:o}=n,{type:i,claimContents:s}=e.body,r=l.fromCTypeAndClaimContents(ye[i],s,n.did);L.debug("Generated claim");const a={attesterDid:x.did,cTypeHash:r.cTypeHash,cost:{tax:{VAT:0},net:le[i],gross:le[i]},currency:"KILT",timeframe:new Date(Date.now()+18e6).toISOString(),termsAndConditions:"https://example.com/terms-and-conditions"},c=await u.createAttesterSignedQuote(a,Z);L.debug("Signed quote");const d=await we(o,{content:{claim:r,legitimations:[],quote:c,cTypes:[ye[i]]},type:"submit-terms"});L.debug("Submit terms complete"),t.send(d)}catch(e){t.status(T.INTERNAL_SERVER_ERROR).send(e)}}));const be=t();be.use(ge),be.use(Ee),be.use(me),be.use(pe),be.use(e.static(`${x.distFolder}/user`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),be.get("*",((e,t)=>{t.sendFile(`${x.distFolder}/user/index.html`)}));(async()=>{await j,L.info("Blockchain connection initialized");const t=e();t.use(n.json()),t.use("/admin",G,re),t.use("/",be),L.info("Routes configured");const o="0.0.0.0",{port:i,baseUri:s}=x,r=t.listen(i,o,(()=>L.info(`Listening on ${s} (host: 0.0.0.0, port: ${i})`)));function a(){r.close(),process.exit(1)}process.on("unhandledRejection",a),process.on("uncaughtException",a)})();
//# sourceMappingURL=server.js.map
