import e,{Router as t}from"express";import n from"body-parser";import{Utils as o,Did as i,connect as s,ConfigService as r,Attestation as a,Blockchain as c,Message as d,Quote as u,CType as p,Credential as y,Claim as l}from"@kiltprotocol/sdk-js";import{cryptoWaitReady as m,randomAsHex as f}from"@polkadot/util-crypto";import{cwd as h}from"node:process";import g from"node:path";import{config as w}from"dotenv";import{pino as E}from"pino";import b from"express-basic-auth";import{StatusCodes as C}from"http-status-codes";import{randomUUID as T}from"node:crypto";import R from"node-cache";w();class N extends Error{constructor(e){super(e),E().fatal(e),process.exit(1)}}const{env:k}=process,A=k.URL;if(!A)throw new N("URL is not provided");const I=k.DID,M=k.SECRET_PAYER_MNEMONIC;if(!M)throw new N("SECRET_PAYER_MNEMONIC is not provided");const D=k.SECRET_AUTHENTICATION_MNEMONIC;if(!D)throw new N("SECRET_AUTHENTICATION_MNEMONIC is not provided");const O=k.SECRET_ASSERTION_METHOD_MNEMONIC;if(!O)throw new N("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const S=k.SECRET_KEY_AGREEMENT_MNEMONIC;if(!S)throw new N("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const _=k.BLOCKCHAIN_ENDPOINT;if(!_)throw new N("No blockchain endpoint provided");const v=k.ADMIN_USERNAME,K=k.ADMIN_PASSWORD;if(!v||!K)throw new N("Admin credentials missing");const U={port:parseInt(k.PORT)||3e3,blockchainEndpoint:_,baseUri:A,distFolder:g.join(h(),"dist","frontend"),did:I,payerMnemonic:M,authenticationMnemonic:D,assertionMethodMnemonic:O,keyAgreementMnemonic:S,adminUsername:v,adminPassword:K},x=(async()=>{await m();return{payer:o.Crypto.makeKeypairFromUri(U.payerMnemonic),authentication:o.Crypto.makeKeypairFromUri(U.authenticationMnemonic),assertionMethod:o.Crypto.makeKeypairFromUri(U.assertionMethodMnemonic),keyAgreement:o.Crypto.makeEncryptionKeypairFromSeed(o.Crypto.mnemonicToMiniSecret(U.keyAgreementMnemonic))}})();async function $(){await s(U.blockchainEndpoint)}async function F(e,t,n){if(!t)throw new Error(`Your on-chain DID is broken: the resolved key for ${n} is undefined`);if(o.Crypto.u8aToHex(e.publicKey)!==o.Crypto.u8aToHex(t.publicKey))throw new Error(`Your on-chain DID is broken: the configured key for ${n} does not match resolved one`)}const H=(async()=>{await $();const{did:e}=U;if(!e)throw new Error("DID not configured, have you run createDID script?");const t=await i.resolve(e);if(!t||!t.document)throw new Error(`Could not resolve the configured DID ${e}, have you run createDID script?`);const{document:n}=t;await async function(e){const t=await x;await F(t.authentication,e.authentication[0],"authentication"),await F(t.assertionMethod,e.assertionMethod?.[0],"assertionMethod"),await F(t.keyAgreement,e.keyAgreement?.[0],"keyAgreement")}(n);const o=n.authentication?.[0];if(!o)throw new Error("Impossible: authentication key not found");const s=n.assertionMethod?.[0];if(!s)throw new Error("Impossible: assertion method key not found");const r=n.keyAgreement?.[0];if(!r)throw new Error("Impossible: key agreement key not found");return{did:e,didDocument:n,authenticationKey:o,assertionMethodKey:s,keyAgreementKey:r}})(),j=E({level:"trace",transport:{target:"pino-pretty"}}),{adminUsername:q,adminPassword:L}=U,P=b({users:{[q]:L},challenge:!0}),B={session:"/api/session",terms:"/api/terms",requestAttestation:"/api/request-attestation",pay:"/api/pay",credentials:{list:"/api/credentials",item:"/api/credentials/:id",attest:"/api/credentials/:id/attest",revoke:"/api/credentials/:id/revoke"}};class G extends Error{}const V=new Map;function Y(e){const t=T();V.set(t,{claim:e})}function Q(e){const t=V.get(e);if(!t)throw new G("Credential not found");return t}function z(e){if(!V.delete(e))throw new G("Credential not found")}function W(e,t){const n=Q(e);return V.set(e,{...n,attestation:t}),Q(e)}async function J({data:e,keyRelationship:t}){if("capabilityDelegation"===t)throw new Error("Delegation not supported");const{authentication:n,assertionMethod:o}=await x,{did:i,authenticationKey:s,assertionMethodKey:r}=await H,[a,c]="authentication"===t?[n,s]:[o,r],d=`${i}${c.id}`;return{signature:a.sign(e,{withType:!1}),keyType:a.type,keyUri:d}}async function X({data:e,peerPublicKey:t}){const{keyAgreement:n}=await x,{did:i,keyAgreementKey:s}=await H,r=`${i}${s.id}`,{box:a,nonce:c}=o.Crypto.encryptAsymmetric(e,t,n.secretKey);return{data:a,nonce:c,keyUri:r}}async function Z({data:e,nonce:t,peerPublicKey:n}){const{keyAgreement:i}=await x,s=o.Crypto.decryptAsymmetric({box:e,nonce:t},n,i.secretKey);if(!s)throw new Error("Failed to decrypt with given key");return{data:s}}async function ee(e){const t=r.get("api"),n=a.fromCredentialAndDid(e,U.did),{claimHash:o,cTypeHash:s}=n,{payer:d}=await x,u=t.tx.attestation.add(o,s,null),p=await i.authorizeTx(U.did,u,J,d.address);return await c.signAndSubmitTx(p,d),n}async function te(e){const t=r.get("api"),{rootHash:n}=e,o=t.tx.attestation.revoke(n,null),{payer:s}=await x,d=await i.authorizeTx(U.did,o,J,s.address);await c.signAndSubmitTx(d,s);const u=await t.query.attestation.attestations(n);return a.fromChain(u,n)}function ne(e,t){j.error(e),e instanceof G?t.status(C.NOT_FOUND).send(e):t.status(C.INTERNAL_SERVER_ERROR).send(e)}const oe=t();oe.get(B.credentials.list,(async(e,t)=>{j.debug("Getting list of credentials"),t.send(Object.fromEntries(V.entries()))})),oe.get(B.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;j.debug("Getting credential"),t.send(Q(n))}catch(e){ne(e,t)}})),oe.delete(B.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;j.debug("Deleting credential"),z(n),t.sendStatus(C.OK)}catch(e){ne(e,t)}})),oe.post(B.credentials.attest,(async(e,t)=>{try{const{id:n}=e.params;j.debug("Getting credential");const{claim:o}=Q(n);j.debug("Attesting credential");const i=await ee(o);j.debug("Credential attested, updating database");const s=W(n,i);t.send(s)}catch(e){ne(e,t)}})),oe.post(B.credentials.revoke,(async(e,t)=>{try{const{id:n}=e.params;j.debug("Getting credential");const{claim:o}=Q(n);j.debug("Revoking credential");const i=await te(o);j.debug("Credential revoked, updating database");const s=W(n,i);t.send(s)}catch(e){ne(e,t)}}));const ie=t();ie.use(oe),ie.use(e.static(`${U.distFolder}/admin`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),ie.get("*",((e,t)=>{t.sendFile(`${U.distFolder}/admin/index.html`)}));const se=new R({stdTTL:18e3,useClones:!1});function re(e){const t=e.get("x-session-id");if(!t)throw new Error("Required header x-session-id is missing");return function(e){const t=se.get(e);if(!t)throw new Error(`Unknown or expired session ${e}`);return t}(t)}function ae(e){se.set(e.sessionId,e)}function ce(e,t,n){try{const t=function(e){const t=re(e),{did:n,didConfirmed:o,encryptionKeyUri:i}=t;if(!n||!o||!i)throw new Error("Unconfirmed DID");return{...t,did:n,encryptionKeyUri:i}}(e);e.session=t,n()}catch(e){t.status(C.FORBIDDEN).send(e)}}const de=t();de.post(B.pay,ce,(async function(e,t){try{j.debug("Mock processing payment");const{session:{credential:n}}=e;if(!n)throw new Error("Session credential not found");Y(n),j.debug("Payment received, sent credential to attester"),t.sendStatus(C.NO_CONTENT)}catch(e){j.error(e),t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const ue={email:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Email",properties:{Email:{type:"string"}},type:"object",$id:"kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac"},twitter:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Twitter",properties:{Twitter:{type:"string"}},type:"object",$id:"kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420"},id:{$schema:"http://kilt-protocol.org/draft-01/ctype#",properties:{age:{type:"integer"},name:{type:"string"}},title:"INE ID",type:"object",$id:"kilt:ctype:0x3112e1e3fb387e5eb6c109aa45afc7ed9df01f1c90a976a8b00585abf817ca82"}},pe={id:2,email:2,twitter:3};const ye=t();function le(){const e=f(24),t=f(24);return ae({sessionId:e,didChallenge:t}),{challenge:t,sessionId:e}}ye.post(B.requestAttestation,ce,(async function(e,t){try{j.debug("Handling attestation request");const n=(await d.decrypt(e.body,Z)).body;j.debug("Request attestation message decrypted"),d.verifyMessageBody(n);const{type:o}=n;if("reject"===o||"reject-terms"===o)return void t.status(C.CONFLICT).send("Message contains rejection");if("request-attestation"!==o)throw new Error("Unexpected message type");const{quote:i,credential:s}=n.content;i&&(await u.verifyQuoteAgreement(i),j.debug("Quote agreement verified"));const r=Object.values(ue),a=p.hashToId(s.claim.cTypeHash),c=r.find((({$id:e})=>e===a));c||t.status(C.FORBIDDEN).send("Unsupported CType"),j.debug("CType supported"),await y.verifyWellFormed(s,{ctype:c}),j.debug("Credential data structure verified");const{session:l}=e;ae({...l,credential:s}),j.debug("Request attestation complete"),t.sendStatus(C.NO_CONTENT)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const me=B.session,fe=t();async function he(e,t){const{did:n}=i.parse(e),o=d.fromBody(t,U.did,n);return d.encrypt(o,X,e)}fe.get(me,(async(e,t)=>{const{did:n,keyAgreementKey:o}=await H,i=`${n}${o.id}`;t.send({dAppEncryptionKeyUri:i,...le()})})),fe.post(me,(function(e,t,n){try{const t=re(e);e.session=t,n()}catch(e){t.status(C.FORBIDDEN).send(e)}}),(async function(e,t){try{j.debug("Session confirmation started");const n=e.body,{encryptionKeyUri:s,encryptedChallenge:r,nonce:a}=n,{session:c}=e,d=await i.resolveKey(s);j.debug("Session confirmation resolved DID encryption key");const{keyAgreementKey:u,did:p}=await H,{data:y}=await Z({data:o.Crypto.coToUInt8(r),nonce:o.Crypto.coToUInt8(a),keyUri:`${p}${u.id}`,peerPublicKey:d.publicKey});j.debug("Session confirmation decrypted challenge");const l=o.Crypto.u8aToHex(y);if(l!==c.didChallenge)return void t.status(C.FORBIDDEN).send("Challenge signature mismatch");ae({...c,did:d.controller,encryptionKeyUri:s,didConfirmed:!0}),j.debug("Challenge confirmation matches"),t.sendStatus(C.NO_CONTENT)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const ge=t();ge.post(B.terms,ce,(async function(e,t){try{j.debug("Submit terms started");const{session:n}=e,{encryptionKeyUri:o}=n,{type:i,claimContents:s}=e.body,r=l.fromCTypeAndClaimContents(ue[i],s,n.did);j.debug("Generated claim");const a={attesterDid:U.did,cTypeHash:r.cTypeHash,cost:{tax:{VAT:0},net:pe[i],gross:pe[i]},currency:"KILT",timeframe:new Date(Date.now()+18e6).toISOString(),termsAndConditions:"https://example.com/terms-and-conditions"},c=await u.createAttesterSignedQuote(a,J);j.debug("Signed quote");const d=await he(o,{content:{claim:r,legitimations:[],quote:c,cTypes:[ue[i]]},type:"submit-terms"});j.debug("Submit terms complete"),t.send(d)}catch(e){t.status(C.INTERNAL_SERVER_ERROR).send(e)}}));const we=t();we.use(fe),we.use(ge),we.use(ye),we.use(de),we.use(e.static(`${U.distFolder}/user`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),we.get("*",((e,t)=>{t.sendFile(`${U.distFolder}/user/index.html`)}));(async()=>{await H,j.info("Blockchain connection initialized");const t=e();t.use(n.json()),t.use("/admin",P,ie),t.use("/",we),j.info("Routes configured");const o="0.0.0.0",{port:i,baseUri:s}=U,r=t.listen(i,o,(()=>j.info(`Listening on ${s} (host: 0.0.0.0, port: ${i})`)));function a(){r.close(),process.exit(1)}process.on("unhandledRejection",a),process.on("uncaughtException",a)})();
//# sourceMappingURL=server.js.map
