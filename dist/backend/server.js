import e,{Router as t}from"express";import n from"body-parser";import{Utils as i,Did as o,connect as s,ConfigService as a,Attestation as r,Blockchain as c,Message as d,Quote as p,CType as u,Credential as y,Claim as l}from"@kiltprotocol/sdk-js";import{cryptoWaitReady as m,randomAsHex as f}from"@polkadot/util-crypto";import{cwd as h}from"node:process";import w from"node:path";import{config as g}from"dotenv";import{pino as E}from"pino";import b from"pino-pretty";import I from"express-basic-auth";import{StatusCodes as R}from"http-status-codes";import{randomUUID as N}from"node:crypto";import{setDoc as C,doc as T,getDocs as A,collection as k,getDoc as M,deleteDoc as D,updateDoc as O,getFirestore as S}from"firebase/firestore";import{getApps as v,initializeApp as _}from"firebase/app";import U from"axios";import x from"node-cache";g();class K extends Error{constructor(e){super(e),E().fatal(e),process.exit(1)}}const{env:F}=process,$=F.URL;if(!$)throw new K("URL is not provided");const Y=F.DID,j=F.SECRET_PAYER_MNEMONIC;if(!j)throw new K("SECRET_PAYER_MNEMONIC is not provided");const H=F.SECRET_AUTHENTICATION_MNEMONIC;if(!H)throw new K("SECRET_AUTHENTICATION_MNEMONIC is not provided");const z=F.SECRET_ASSERTION_METHOD_MNEMONIC;if(!z)throw new K("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const L=F.SECRET_KEY_AGREEMENT_MNEMONIC;if(!L)throw new K("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const J=F.BLOCKCHAIN_ENDPOINT;if(!J)throw new K("No blockchain endpoint provided");const V=F.ADMIN_USERNAME,W=F.ADMIN_PASSWORD;if(!V||!W)throw new K("Admin credentials missing");const G={port:parseInt(F.PORT)||3e3,blockchainEndpoint:J,baseUri:$,distFolder:w.join(h(),"dist","frontend"),did:Y,payerMnemonic:j,authenticationMnemonic:H,assertionMethodMnemonic:z,keyAgreementMnemonic:L,adminUsername:V,adminPassword:W},q=(async()=>{await m();return{payer:i.Crypto.makeKeypairFromUri(G.payerMnemonic),authentication:i.Crypto.makeKeypairFromUri(G.authenticationMnemonic),assertionMethod:i.Crypto.makeKeypairFromUri(G.assertionMethodMnemonic),keyAgreement:i.Crypto.makeEncryptionKeypairFromSeed(i.Crypto.mnemonicToMiniSecret(G.keyAgreementMnemonic))}})();async function Q(){await s(G.blockchainEndpoint)}async function B(e,t,n){if(!t)throw new Error(`Your on-chain DID is broken: the resolved key for ${n} is undefined`);if(i.Crypto.u8aToHex(e.publicKey)!==i.Crypto.u8aToHex(t.publicKey))throw new Error(`Your on-chain DID is broken: the configured key for ${n} does not match resolved one`)}const X=(async()=>{await Q();const{did:e}=G;if(!e)throw new Error("DID not configured, have you run createDID script?");const t=await o.resolve(e);if(!t||!t.document)throw new Error(`Could not resolve the configured DID ${e}, have you run createDID script?`);const{document:n}=t;await async function(e){const t=await q;await B(t.authentication,e.authentication[0],"authentication"),await B(t.assertionMethod,e.assertionMethod?.[0],"assertionMethod"),await B(t.keyAgreement,e.keyAgreement?.[0],"keyAgreement")}(n);const i=n.authentication?.[0];if(!i)throw new Error("Impossible: authentication key not found");const s=n.assertionMethod?.[0];if(!s)throw new Error("Impossible: assertion method key not found");const a=n.keyAgreement?.[0];if(!a)throw new Error("Impossible: key agreement key not found");return{did:e,didDocument:n,authenticationKey:i,assertionMethodKey:s,keyAgreementKey:a}})(),Z=b({levelFirst:!0,colorize:!0,ignore:"time,hostname,pid"}),P=E({level:"trace"},Z),{adminUsername:ee,adminPassword:te}=G,ne=I({users:{[ee]:te},challenge:!0}),ie={session:"/api/session",terms:"/api/terms",requestAttestation:"/api/request-attestation",pay:"/api/pay",credentials:{list:"/api/credentials",item:"/api/credentials/:id",attest:"/api/credentials/:id/attest",revoke:"/api/credentials/:id/revoke"}},oe=v(),se=S(oe.length>0?oe[0]:_({apiKey:"AIzaSyAAwR5GvEUi3lLWy9bb1tz65jhvHI3vufc",authDomain:"peranto-test.firebaseapp.com",projectId:"peranto-test",storageBucket:"peranto-test.appspot.com",messagingSenderId:"777447831295",appId:"1:777447831295:web:6a987d7c8b307ecef43eca"}));const ae=t();ae.post("/api/truora",(async function(e,t){try{const{accountId:n,validationId:i}=e.body,{data:o}=await U.get(`https://api.validations.truora.com/v1/validations/${i}`,{headers:{"Truora-API-Key":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2NvdW50X2lkIjoiIiwiYWRkaXRpb25hbF9kYXRhIjoie30iLCJjbGllbnRfaWQiOiJUQ0llNTEwMjRiOTlmN2YwZDc2NzZhYTFlOGI1NWY3YmI4MiIsImV4cCI6MzI2NTQ3OTQ2MywiZ3JhbnQiOiIiLCJpYXQiOjE2ODg2Nzk0NjMsImlzcyI6Imh0dHBzOi8vY29nbml0by1pZHAudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vdXMtZWFzdC0xX1lZY2VRNXlxSSIsImp0aSI6ImVkMzZhMGQwLTYxYjgtNDQ0Ni04OWNmLWFiNDEwYWY5NDkyNCIsImtleV9uYW1lIjoicGVyYW50b3Rlc3QiLCJrZXlfdHlwZSI6ImJhY2tlbmQiLCJ1c2VybmFtZSI6InBlcmFudG9zZXJ2aWNlcy1wZXJhbnRvdGVzdCJ9.gVB8petsqNJAmwSUUF8AKwzx8UUezTpyqrsEIH36ses"}}),s=await C(T(se,"truora","testId_"+i),{...o,accountId:n,validationId:i});t.json({docRef:s})}catch(e){P.error(e),t.status(R.INTERNAL_SERVER_ERROR).send(e)}}));class re extends Error{}function ce(e){const t=N();C(T(se,"credentials",t),{claim:e})}async function de(){let e={};return(await A(k(se,"credentials"))).forEach((t=>{e={...e,[t.id]:{...t.data(),id:t.id}}})),e}async function pe(e){const t={...(await M(T(se,"credentials",e))).data(),id:e};if(!t)throw new re("Credential not found");return t}async function ue(e){await D(T(se,"credentials",e))}async function ye(e,t){const n=await pe(e);return await O(T(se,"credentials",e),{...n,attestation:t}),await pe(e)}async function le({data:e,keyRelationship:t}){if("capabilityDelegation"===t)throw new Error("Delegation not supported");const{authentication:n,assertionMethod:i}=await q,{did:o,authenticationKey:s,assertionMethodKey:a}=await X,[r,c]="authentication"===t?[n,s]:[i,a],d=`${o}${c.id}`;return{signature:r.sign(e,{withType:!1}),keyType:r.type,keyUri:d}}async function me({data:e,peerPublicKey:t}){const{keyAgreement:n}=await q,{did:o,keyAgreementKey:s}=await X,a=`${o}${s.id}`,{box:r,nonce:c}=i.Crypto.encryptAsymmetric(e,t,n.secretKey);return{data:r,nonce:c,keyUri:a}}async function fe({data:e,nonce:t,peerPublicKey:n}){const{keyAgreement:o}=await q,s=i.Crypto.decryptAsymmetric({box:e,nonce:t},n,o.secretKey);if(!s)throw new Error("Failed to decrypt with given key");return{data:s}}async function he(e){const t=a.get("api"),n=r.fromCredentialAndDid(e,G.did),{claimHash:i,cTypeHash:s}=n,{payer:d}=await q,p=t.tx.attestation.add(i,s,null),u=await o.authorizeTx(G.did,p,le,d.address);return await c.signAndSubmitTx(u,d),n}async function we(e){const t=a.get("api"),{rootHash:n}=e,i=t.tx.attestation.revoke(n,null),{payer:s}=await q,d=await o.authorizeTx(G.did,i,le,s.address);await c.signAndSubmitTx(d,s);const p=await t.query.attestation.attestations(n);return r.fromChain(p,n)}function ge(e,t){P.error(e),e instanceof re?t.status(R.NOT_FOUND).send(e):t.status(R.INTERNAL_SERVER_ERROR).send(e)}const Ee=t();Ee.get(ie.credentials.list,(async(e,t)=>{P.debug("Getting list of credentials"),t.send(await de())})),Ee.get(ie.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Getting credential"),t.send(await pe(n))}catch(e){ge(e,t)}})),Ee.delete(ie.credentials.item,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Deleting credential"),await ue(n),t.sendStatus(R.OK)}catch(e){ge(e,t)}})),Ee.post(ie.credentials.attest,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Getting credential");const{claim:i}=await pe(n);P.debug("Attesting credential");const o=await he(i);P.debug("Credential attested, updating database");const s=await ye(n,o);t.send(s)}catch(e){ge(e,t)}})),Ee.post(ie.credentials.revoke,(async(e,t)=>{try{const{id:n}=e.params;P.debug("Getting credential");const{claim:i}=await pe(n);P.debug("Revoking credential");const o=await we(i);P.debug("Credential revoked, updating database");const s=await ye(n,o);t.send(s)}catch(e){ge(e,t)}}));const be=t();be.use(Ee),be.use(e.static(`${G.distFolder}/admin`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),be.get("*",((e,t)=>{t.sendFile(`${G.distFolder}/admin/index.html`)}));const Ie=new x({stdTTL:18e3,useClones:!1});function Re(e){const t=e.get("x-session-id");if(!t)throw new Error("Required header x-session-id is missing");return function(e){const t=Ie.get(e);if(!t)throw new Error(`Unknown or expired session ${e}`);return t}(t)}function Ne(e){Ie.set(e.sessionId,e)}function Ce(e,t,n){try{const t=function(e){const t=Re(e),{did:n,didConfirmed:i,encryptionKeyUri:o}=t;if(!n||!i||!o)throw new Error("Unconfirmed DID");return{...t,did:n,encryptionKeyUri:o}}(e);e.session=t,n()}catch(e){t.status(R.FORBIDDEN).send(e)}}const Te=t();Te.post(ie.pay,Ce,(async function(e,t){try{P.debug("Mock processing payment");const{session:{credential:n}}=e;if(!n)throw new Error("Session credential not found");ce(n),P.debug("Payment received, sent credential to attester"),t.sendStatus(R.NO_CONTENT)}catch(e){P.error(e),t.status(R.INTERNAL_SERVER_ERROR).send(e)}}));const Ae={email:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Email",properties:{Email:{type:"string"}},type:"object",$id:"kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac"},twitter:{$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Twitter",properties:{Twitter:{type:"string"}},type:"object",$id:"kilt:ctype:0x47d04c42bdf7fdd3fc5a194bcaa367b2f4766a6b16ae3df628927656d818f420"},id:{$schema:"http://kilt-protocol.org/draft-01/ctype#",properties:{email:{type:"string"},username:{type:"string"}},title:"Authorization",type:"object",$id:"kilt:ctype:0xdf952230c87e7fbdc8503a394540c8e99029180611e7107c4eee33f67f57aa57"}},ke={id:2,email:2,twitter:3};const Me=t();function De(){const e=f(24),t=f(24);return Ne({sessionId:e,didChallenge:t}),{challenge:t,sessionId:e}}Me.post(ie.requestAttestation,Ce,(async function(e,t){try{P.debug("Handling attestation request");const n=(await d.decrypt(e.body,fe)).body;P.debug("Request attestation message decrypted"),d.verifyMessageBody(n);const{type:i}=n;if("reject"===i||"reject-terms"===i)return void t.status(R.CONFLICT).send("Message contains rejection");if("request-attestation"!==i)throw new Error("Unexpected message type");const{quote:o,credential:s}=n.content;o&&(await p.verifyQuoteAgreement(o),P.debug("Quote agreement verified"));const a=Object.values(Ae),r=u.hashToId(s.claim.cTypeHash),c=a.find((({$id:e})=>e===r));c||t.status(R.FORBIDDEN).send("Unsupported CType"),P.debug("CType supported"),await y.verifyWellFormed(s,{ctype:c}),P.debug("Credential data structure verified");const{session:l}=e;Ne({...l,credential:s}),P.debug("Request attestation complete"),t.sendStatus(R.NO_CONTENT)}catch(e){t.status(R.INTERNAL_SERVER_ERROR).send(e)}}));const Oe=ie.session,Se=t();async function ve(e,t){const{did:n}=o.parse(e),i=d.fromBody(t,G.did,n);return d.encrypt(i,me,e)}Se.get(Oe,(async(e,t)=>{const{did:n,keyAgreementKey:i}=await X,o=`${n}${i.id}`;t.send({dAppEncryptionKeyUri:o,...De()})})),Se.post(Oe,(function(e,t,n){try{const t=Re(e);e.session=t,n()}catch(e){t.status(R.FORBIDDEN).send(e)}}),(async function(e,t){try{P.debug("Session confirmation started");const n=e.body,{encryptionKeyUri:s,encryptedChallenge:a,nonce:r}=n,{session:c}=e,d=await o.resolveKey(s);P.debug("Session confirmation resolved DID encryption key");const{keyAgreementKey:p,did:u}=await X,{data:y}=await fe({data:i.Crypto.coToUInt8(a),nonce:i.Crypto.coToUInt8(r),keyUri:`${u}${p.id}`,peerPublicKey:d.publicKey});P.debug("Session confirmation decrypted challenge");const l=i.Crypto.u8aToHex(y);if(l!==c.didChallenge)return void t.status(R.FORBIDDEN).send("Challenge signature mismatch");Ne({...c,did:d.controller,encryptionKeyUri:s,didConfirmed:!0}),P.debug("Challenge confirmation matches"),t.sendStatus(R.NO_CONTENT)}catch(e){t.status(R.INTERNAL_SERVER_ERROR).send(e)}}));const _e=t();_e.post(ie.terms,Ce,(async function(e,t){try{P.debug("Submit terms started");const{session:n}=e,{encryptionKeyUri:i}=n,{type:o,claimContents:s}=e.body;P.info("ctype: "+JSON.stringify(Ae[o]));const a=l.fromCTypeAndClaimContents(Ae[o],s,n.did);P.debug("Generated claim");const r={attesterDid:G.did,cTypeHash:a.cTypeHash,cost:{tax:{VAT:0},net:ke[o],gross:ke[o]},currency:"KILT",timeframe:new Date(Date.now()+18e6).toISOString(),termsAndConditions:"https://example.com/terms-and-conditions"},c=await p.createAttesterSignedQuote(r,le);P.debug("Signed quote");const d=await ve(i,{content:{claim:a,legitimations:[],quote:c,cTypes:[Ae[o]]},type:"submit-terms"});P.debug("Submit terms complete"),t.send(d)}catch(e){t.status(R.INTERNAL_SERVER_ERROR).send(e)}}));const Ue=t();Ue.use(Se),Ue.use(_e),Ue.use(Me),Ue.use(Te),Ue.use(ae),Ue.use(e.static(`${G.distFolder}/user`,{dotfiles:"allow",setHeaders(e){e.set("Access-Control-Allow-Origin","*")}})),Ue.get("*",((e,t)=>{t.sendFile(`${G.distFolder}/user/index.html`)}));(async()=>{await X,P.info("Blockchain connection initialized");const t=e();t.use(n.json()),t.use("/admin",ne,be),t.use("/",Ue),P.info("Routes configured");const i="0.0.0.0",{port:o,baseUri:s}=G,a=t.listen(o,i,(()=>P.info(`Listening on ${s} (host: 0.0.0.0, port: ${o})`)));function r(){a.close(),process.exit(1)}process.on("unhandledRejection",r),process.on("uncaughtException",r)})();
//# sourceMappingURL=server.js.map
