import{ConfigService as t,BalanceUtils as e,Did as o,Blockchain as n,disconnect as i,connect as r,Utils as a}from"@kiltprotocol/sdk-js";import{cwd as s}from"node:process";import c from"node:path";import{config as d}from"dotenv";import{pino as p}from"pino";import{cryptoWaitReady as E}from"@polkadot/util-crypto";d();class m extends Error{constructor(t){super(t),p().fatal(t),process.exit(1)}}const{env:y}=process,M=y.URL;if(!M)throw new m("URL is not provided");const h=y.DID,w=y.SECRET_PAYER_MNEMONIC;if(!w)throw new m("SECRET_PAYER_MNEMONIC is not provided");const N=y.SECRET_AUTHENTICATION_MNEMONIC;if(!N)throw new m("SECRET_AUTHENTICATION_MNEMONIC is not provided");const T=y.SECRET_ASSERTION_METHOD_MNEMONIC;if(!T)throw new m("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const l=y.SECRET_KEY_AGREEMENT_MNEMONIC;if(!l)throw new m("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const C=y.BLOCKCHAIN_ENDPOINT;if(!C)throw new m("No blockchain endpoint provided");const f=y.ADMIN_USERNAME,A=y.ADMIN_PASSWORD;if(!f||!A)throw new m("Admin credentials missing");const I={port:parseInt(y.PORT)||3e3,blockchainEndpoint:C,baseUri:M,distFolder:c.join(s(),"dist","frontend"),did:h,payerMnemonic:w,authenticationMnemonic:N,assertionMethodMnemonic:T,keyAgreementMnemonic:l,adminUsername:f,adminPassword:A};async function _(){await r(I.blockchainEndpoint)}const S=(async()=>{await E();return{payer:a.Crypto.makeKeypairFromUri(I.payerMnemonic),authentication:a.Crypto.makeKeypairFromUri(I.authenticationMnemonic),assertionMethod:a.Crypto.makeKeypairFromUri(I.assertionMethodMnemonic),keyAgreement:a.Crypto.makeEncryptionKeypairFromSeed(a.Crypto.mnemonicToMiniSecret(I.keyAgreementMnemonic))}})(),k=p({level:"trace",transport:{target:"pino-pretty"}});(async()=>{if(await _(),I.did)throw new Error(`DID ${I.did} already exists on the blockchain ${I.blockchainEndpoint}`);const{assertionMethod:r,authentication:a,payer:s,keyAgreement:c}=await S,d=t.get("api"),p=(await d.query.system.account(s.address)).data.free;if(p.lt(e.toFemtoKilt(10))){const t=e.formatKiltBalance(p);throw new Error(`The payer account ${s.address} has insufficient funds ${t}`)}const E=await o.getStoreTx({authentication:[a],assertionMethod:[r],keyAgreement:[c]},s.address,(async({data:t})=>({signature:a.sign(t,{withType:!1}),keyType:a.type})));k.warn("Storing the DID on the blockchainâ€¦"),await n.signAndSubmitTx(E,s);const m=o.getFullDidUriFromKey(a);k.warn(`Add this to your .env: DID=${m}`),await i()})();
//# sourceMappingURL=createDID.js.map
