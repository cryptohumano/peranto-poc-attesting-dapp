import{ConfigService as t,BalanceUtils as e,Did as o,Blockchain as n,disconnect as i,connect as r,Utils as a}from"@kiltprotocol/sdk-js";import{cwd as s}from"node:process";import c from"node:path";import{config as d}from"dotenv";import{pino as p}from"pino";import{cryptoWaitReady as E}from"@polkadot/util-crypto";import m from"pino-pretty";d();class y extends Error{constructor(t){super(t),p().fatal(t),process.exit(1)}}const{env:M}=process,h=M.URL;if(!h)throw new y("URL is not provided");const w=M.DID,N=M.SECRET_PAYER_MNEMONIC;if(!N)throw new y("SECRET_PAYER_MNEMONIC is not provided");const l=M.SECRET_AUTHENTICATION_MNEMONIC;if(!l)throw new y("SECRET_AUTHENTICATION_MNEMONIC is not provided");const T=M.SECRET_ASSERTION_METHOD_MNEMONIC;if(!T)throw new y("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const f=M.SECRET_KEY_AGREEMENT_MNEMONIC;if(!f)throw new y("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const C=M.BLOCKCHAIN_ENDPOINT;if(!C)throw new y("No blockchain endpoint provided");const A=M.ADMIN_USERNAME,I=M.ADMIN_PASSWORD;if(!A||!I)throw new y("Admin credentials missing");const _={port:parseInt(M.PORT)||3e3,blockchainEndpoint:C,baseUri:h,distFolder:c.join(s(),"dist","frontend"),did:w,payerMnemonic:N,authenticationMnemonic:l,assertionMethodMnemonic:T,keyAgreementMnemonic:f,adminUsername:A,adminPassword:I};async function S(){await r(_.blockchainEndpoint)}const k=(async()=>{await E();return{payer:a.Crypto.makeKeypairFromUri(_.payerMnemonic),authentication:a.Crypto.makeKeypairFromUri(_.authenticationMnemonic),assertionMethod:a.Crypto.makeKeypairFromUri(_.assertionMethodMnemonic),keyAgreement:a.Crypto.makeEncryptionKeypairFromSeed(a.Crypto.mnemonicToMiniSecret(_.keyAgreementMnemonic))}})(),R=m({levelFirst:!0,colorize:!0,ignore:"time,hostname,pid"}),u=p({level:"trace"},R);(async()=>{if(await S(),_.did)throw new Error(`DID ${_.did} already exists on the blockchain ${_.blockchainEndpoint}`);const{assertionMethod:r,authentication:a,payer:s,keyAgreement:c}=await k,d=t.get("api"),p=(await d.query.system.account(s.address)).data.free;if(p.lt(e.toFemtoKilt(10))){const t=e.formatKiltBalance(p);throw new Error(`The payer account ${s.address} has insufficient funds ${t}`)}const E=await o.getStoreTx({authentication:[a],assertionMethod:[r],keyAgreement:[c]},s.address,(async({data:t})=>({signature:a.sign(t,{withType:!1}),keyType:a.type})));u.warn("Storing the DID on the blockchainâ€¦"),await n.signAndSubmitTx(E,s);const m=o.getFullDidUriFromKey(a);u.warn(`Add this to your .env: DID=${m}`),await i()})();
//# sourceMappingURL=createDID.js.map
