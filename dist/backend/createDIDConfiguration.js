import{lstat as e,mkdir as t,writeFile as o}from"node:fs/promises";import n,{join as i}from"node:path";import{disconnect as r,Claim as a,Credential as s,Utils as c,Did as d,connect as p}from"@kiltprotocol/sdk-js";import{cwd as E}from"node:process";import{config as m}from"dotenv";import{pino as y}from"pino";import{constants as l}from"@kiltprotocol/vc-export";import{cryptoWaitReady as w}from"@polkadot/util-crypto";m();class h extends Error{constructor(e){super(e),y().fatal(e),process.exit(1)}}const{env:f}=process,u=f.URL;if(!u)throw new h("URL is not provided");const k=f.DID,I=f.SECRET_PAYER_MNEMONIC;if(!I)throw new h("SECRET_PAYER_MNEMONIC is not provided");const M=f.SECRET_AUTHENTICATION_MNEMONIC;if(!M)throw new h("SECRET_AUTHENTICATION_MNEMONIC is not provided");const C=f.SECRET_ASSERTION_METHOD_MNEMONIC;if(!C)throw new h("SECRET_ASSERTION_METHOD_MNEMONIC is not provided");const g=f.SECRET_KEY_AGREEMENT_MNEMONIC;if(!g)throw new h("SECRET_KEY_AGREEMENT_MNEMONIC is not provided");const T=f.BLOCKCHAIN_ENDPOINT;if(!T)throw new h("No blockchain endpoint provided");const D=f.ADMIN_USERNAME,N=f.ADMIN_PASSWORD;if(!D||!N)throw new h("Admin credentials missing");const _={port:parseInt(f.PORT)||3e3,blockchainEndpoint:T,baseUri:u,distFolder:n.join(E(),"dist","frontend"),did:k,payerMnemonic:I,authenticationMnemonic:M,assertionMethodMnemonic:C,keyAgreementMnemonic:g,adminUsername:D,adminPassword:N},A={$schema:"http://kilt-protocol.org/draft-01/ctype#",title:"Domain Linkage Credential",properties:{id:{type:"string"},origin:{type:"string"}},type:"object",$id:"kilt:ctype:0x9d271c790775ee831352291f01c5d04c7979713a5896dcf5e81708184cc5c643"},R=(async()=>{await w();return{payer:c.Crypto.makeKeypairFromUri(_.payerMnemonic),authentication:c.Crypto.makeKeypairFromUri(_.authenticationMnemonic),assertionMethod:c.Crypto.makeKeypairFromUri(_.assertionMethodMnemonic),keyAgreement:c.Crypto.makeEncryptionKeypairFromSeed(c.Crypto.mnemonicToMiniSecret(_.keyAgreementMnemonic))}})();async function S(){await p(_.blockchainEndpoint)}async function O(e,t,o){if(!t)throw new Error(`Your on-chain DID is broken: the resolved key for ${o} is undefined`);if(c.Crypto.u8aToHex(e.publicKey)!==c.Crypto.u8aToHex(t.publicKey))throw new Error(`Your on-chain DID is broken: the configured key for ${o} does not match resolved one`)}const v=(async()=>{await S();const{did:e}=_;if(!e)throw new Error("DID not configured, have you run createDID script?");const t=await d.resolve(e);if(!t||!t.document)throw new Error(`Could not resolve the configured DID ${e}, have you run createDID script?`);const{document:o}=t;await async function(e){const t=await R;await O(t.authentication,e.authentication[0],"authentication"),await O(t.assertionMethod,e.assertionMethod?.[0],"assertionMethod"),await O(t.keyAgreement,e.keyAgreement?.[0],"keyAgreement")}(o);const n=o.authentication?.[0];if(!n)throw new Error("Impossible: authentication key not found");const i=o.assertionMethod?.[0];if(!i)throw new Error("Impossible: assertion method key not found");const r=o.keyAgreement?.[0];if(!r)throw new Error("Impossible: key agreement key not found");return{did:e,didDocument:o,authenticationKey:n,assertionMethodKey:i,keyAgreementKey:r}})();async function L({data:e}){const{assertionMethod:t}=await R,{did:o,assertionMethodKey:n}=await v,i=`${o}${n.id}`;return{signature:t.sign(e,{withType:!1}),keyType:t.type,keyUri:i}}const{DEFAULT_VERIFIABLECREDENTIAL_CONTEXT:U,DEFAULT_VERIFIABLECREDENTIAL_TYPE:b,KILT_SELF_SIGNED_PROOF_TYPE:K,KILT_VERIFIABLECREDENTIAL_TYPE:F}=l,P=[U,"https://identity.foundation/.well-known/did-configuration/v1"];async function x(){const e={id:_.did,origin:_.baseUri},t=a.fromCTypeAndClaimContents(A,e,_.did),o=s.fromClaim(t);return s.createPresentation({credential:o,signCallback:L})}function H(e){const t={...e.claim.contents,rootHash:e.rootHash},o=e.claim.owner,n=(new Date).toISOString(),i=new Date(Date.now()+15768e7).toISOString(),{claimerSignature:r}=e,a={type:K,proofPurpose:"assertionMethod",verificationMethod:r.keyUri,signature:r.signature,challenge:r.challenge};return{"@context":P,issuer:o,issuanceDate:n,expirationDate:i,type:[b,"DomainLinkageCredential",F],credentialSubject:t,proof:a}}(async()=>{console.log(`Generating the .well-known/did-configuration.json file for DID ${_.did} and host ${_.baseUri}`);const n=i(_.distFolder,"user",".well-known");try{await e(n)}catch(e){console.warn("Looks like the .well-known folder doesnâ€™t exist, creating",e.message),await t(n)}const a={"@context":"https://identity.foundation/.well-known/did-configuration/v1",linked_dids:[H(await x())]},s=JSON.stringify(a),c=i(n,"did-configuration.json");await o(c,s),await r()})();
//# sourceMappingURL=createDIDConfiguration.js.map
